{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _classCallCheck = require(\"/Users/randysteele/gone-fishin/gone-fishin-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/randysteele/gone-fishin/gone-fishin-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar logger_1 = require(\"./logger\");\n/*\n * @module firestore/backoff\n * @private\n *\n * Contains backoff logic to facilitate RPC error handling. This class derives\n * its implementation from the Firestore Mobile Web Client.\n *\n * @see https://github.com/firebase/firebase-js-sdk/blob/master/packages/firestore/src/remote/backoff.ts\n */\n\n/*!\n * The default initial backoff time in milliseconds after an error.\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\n */\n\n\nvar DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;\n/*!\n * The default maximum backoff time in milliseconds.\n */\n\nvar DEFAULT_BACKOFF_MAX_DELAY_MS = 60 * 1000;\n/*!\n * The default factor to increase the backup by after each failed attempt.\n */\n\nvar DEFAULT_BACKOFF_FACTOR = 1.5;\n/*!\n * The default jitter to distribute the backoff attempts by (0 means no\n * randomization, 1.0 means +/-50% randomization).\n */\n\nvar DEFAULT_JITTER_FACTOR = 1.0;\n/*!\n * The maximum number of retries that will be attempted by backoff\n * before stopping all retry attempts.\n */\n\nexports.MAX_RETRY_ATTEMPTS = 10;\n/*!\n * The timeout handler used by `ExponentialBackoff` and `BulkWriter`.\n */\n\nexports.delayExecution = setTimeout;\n/**\n * Allows overriding of the timeout handler used by the exponential backoff\n * implementation. If not invoked, we default to `setTimeout()`.\n *\n * Used only in testing.\n *\n * @private\n * @param {function} handler A handler than matches the API of `setTimeout()`.\n */\n\nfunction setTimeoutHandler(handler) {\n  exports.delayExecution = function (f, ms) {\n    handler(f, ms);\n    var timeout = {\n      hasRef: function hasRef() {\n        throw new Error('For tests only. Not Implemented');\n      },\n      ref: function ref() {\n        throw new Error('For tests only. Not Implemented');\n      },\n      refresh: function refresh() {\n        throw new Error('For tests only. Not Implemented');\n      },\n      unref: function unref() {\n        throw new Error('For tests only. Not Implemented');\n      }\n    };\n    return timeout;\n  };\n}\n\nexports.setTimeoutHandler = setTimeoutHandler;\n/**\n * A helper for running delayed tasks following an exponential backoff curve\n * between attempts.\n *\n * Each delay is made up of a \"base\" delay which follows the exponential\n * backoff curve, and a \"jitter\" (+/- 50% by default)  that is calculated and\n * added to the base delay. This prevents clients from accidentally\n * synchronizing their delays causing spikes of load to the backend.\n *\n * @private\n */\n\nvar ExponentialBackoff = /*#__PURE__*/function () {\n  function ExponentialBackoff() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, ExponentialBackoff);\n\n    /**\n     * The number of retries that has been attempted.\n     *\n     * @private\n     */\n    this._retryCount = 0;\n    /**\n     * The backoff delay of the current attempt.\n     *\n     * @private\n     */\n\n    this.currentBaseMs = 0;\n    /**\n     * Whether we are currently waiting for backoff to complete.\n     *\n     * @private\n     */\n\n    this.awaitingBackoffCompletion = false;\n    this.initialDelayMs = options.initialDelayMs !== undefined ? options.initialDelayMs : DEFAULT_BACKOFF_INITIAL_DELAY_MS;\n    this.backoffFactor = options.backoffFactor !== undefined ? options.backoffFactor : DEFAULT_BACKOFF_FACTOR;\n    this.maxDelayMs = options.maxDelayMs !== undefined ? options.maxDelayMs : DEFAULT_BACKOFF_MAX_DELAY_MS;\n    this.jitterFactor = options.jitterFactor !== undefined ? options.jitterFactor : DEFAULT_JITTER_FACTOR;\n  }\n  /**\n   * Resets the backoff delay and retry count.\n   *\n   * The very next backoffAndWait() will have no delay. If it is called again\n   * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\n   * subsequent ones will increase according to the backoffFactor.\n   *\n   * @private\n   */\n\n\n  _createClass(ExponentialBackoff, [{\n    key: \"reset\",\n    value: function reset() {\n      this._retryCount = 0;\n      this.currentBaseMs = 0;\n    }\n    /**\n     * Resets the backoff delay to the maximum delay (e.g. for use after a\n     * RESOURCE_EXHAUSTED error).\n     *\n     * @private\n     */\n\n  }, {\n    key: \"resetToMax\",\n    value: function resetToMax() {\n      this.currentBaseMs = this.maxDelayMs;\n    }\n    /**\n     * Returns a promise that resolves after currentDelayMs, and increases the\n     * delay for any subsequent attempts.\n     *\n     * @return A Promise that resolves when the current delay elapsed.\n     * @private\n     */\n\n  }, {\n    key: \"backoffAndWait\",\n    value: function backoffAndWait() {\n      var _this = this;\n\n      if (this.awaitingBackoffCompletion) {\n        return Promise.reject(new Error('A backoff operation is already in progress.'));\n      }\n\n      if (this.retryCount > exports.MAX_RETRY_ATTEMPTS) {\n        return Promise.reject(new Error('Exceeded maximum number of retries allowed.'));\n      } // First schedule using the current base (which may be 0 and should be\n      // honored as such).\n\n\n      var delayWithJitterMs = this.currentBaseMs + this.jitterDelayMs();\n\n      if (this.currentBaseMs > 0) {\n        logger_1.logger('ExponentialBackoff.backoffAndWait', null, \"Backing off for \".concat(delayWithJitterMs, \" ms \") + \"(base delay: \".concat(this.currentBaseMs, \" ms)\"));\n      } // Apply backoff factor to determine next delay and ensure it is within\n      // bounds.\n\n\n      this.currentBaseMs *= this.backoffFactor;\n      this.currentBaseMs = Math.max(this.currentBaseMs, this.initialDelayMs);\n      this.currentBaseMs = Math.min(this.currentBaseMs, this.maxDelayMs);\n      this._retryCount += 1;\n      return new Promise(function (resolve) {\n        _this.awaitingBackoffCompletion = true;\n        exports.delayExecution(function () {\n          _this.awaitingBackoffCompletion = false;\n          resolve();\n        }, delayWithJitterMs);\n      });\n    } // Visible for testing.\n\n  }, {\n    key: \"jitterDelayMs\",\n\n    /**\n     * Returns a randomized \"jitter\" delay based on the current base and jitter\n     * factor.\n     *\n     * @returns {number} The jitter to apply based on the current delay.\n     * @private\n     */\n    value: function jitterDelayMs() {\n      return (Math.random() - 0.5) * this.jitterFactor * this.currentBaseMs;\n    }\n  }, {\n    key: \"retryCount\",\n    get: function get() {\n      return this._retryCount;\n    }\n  }]);\n\n  return ExponentialBackoff;\n}();\n\nexports.ExponentialBackoff = ExponentialBackoff;","map":{"version":3,"sources":["/Users/randysteele/gone-fishin/gone-fishin-frontend/node_modules/@google-cloud/firestore/build/src/backoff.js"],"names":["Object","defineProperty","exports","value","logger_1","require","DEFAULT_BACKOFF_INITIAL_DELAY_MS","DEFAULT_BACKOFF_MAX_DELAY_MS","DEFAULT_BACKOFF_FACTOR","DEFAULT_JITTER_FACTOR","MAX_RETRY_ATTEMPTS","delayExecution","setTimeout","setTimeoutHandler","handler","f","ms","timeout","hasRef","Error","ref","refresh","unref","ExponentialBackoff","options","_retryCount","currentBaseMs","awaitingBackoffCompletion","initialDelayMs","undefined","backoffFactor","maxDelayMs","jitterFactor","Promise","reject","retryCount","delayWithJitterMs","jitterDelayMs","logger","Math","max","min","resolve","random"],"mappings":"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","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst logger_1 = require(\"./logger\");\n/*\n * @module firestore/backoff\n * @private\n *\n * Contains backoff logic to facilitate RPC error handling. This class derives\n * its implementation from the Firestore Mobile Web Client.\n *\n * @see https://github.com/firebase/firebase-js-sdk/blob/master/packages/firestore/src/remote/backoff.ts\n */\n/*!\n * The default initial backoff time in milliseconds after an error.\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\n */\nconst DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;\n/*!\n * The default maximum backoff time in milliseconds.\n */\nconst DEFAULT_BACKOFF_MAX_DELAY_MS = 60 * 1000;\n/*!\n * The default factor to increase the backup by after each failed attempt.\n */\nconst DEFAULT_BACKOFF_FACTOR = 1.5;\n/*!\n * The default jitter to distribute the backoff attempts by (0 means no\n * randomization, 1.0 means +/-50% randomization).\n */\nconst DEFAULT_JITTER_FACTOR = 1.0;\n/*!\n * The maximum number of retries that will be attempted by backoff\n * before stopping all retry attempts.\n */\nexports.MAX_RETRY_ATTEMPTS = 10;\n/*!\n * The timeout handler used by `ExponentialBackoff` and `BulkWriter`.\n */\nexports.delayExecution = setTimeout;\n/**\n * Allows overriding of the timeout handler used by the exponential backoff\n * implementation. If not invoked, we default to `setTimeout()`.\n *\n * Used only in testing.\n *\n * @private\n * @param {function} handler A handler than matches the API of `setTimeout()`.\n */\nfunction setTimeoutHandler(handler) {\n    exports.delayExecution = (f, ms) => {\n        handler(f, ms);\n        const timeout = {\n            hasRef: () => {\n                throw new Error('For tests only. Not Implemented');\n            },\n            ref: () => {\n                throw new Error('For tests only. Not Implemented');\n            },\n            refresh: () => {\n                throw new Error('For tests only. Not Implemented');\n            },\n            unref: () => {\n                throw new Error('For tests only. Not Implemented');\n            },\n        };\n        return timeout;\n    };\n}\nexports.setTimeoutHandler = setTimeoutHandler;\n/**\n * A helper for running delayed tasks following an exponential backoff curve\n * between attempts.\n *\n * Each delay is made up of a \"base\" delay which follows the exponential\n * backoff curve, and a \"jitter\" (+/- 50% by default)  that is calculated and\n * added to the base delay. This prevents clients from accidentally\n * synchronizing their delays causing spikes of load to the backend.\n *\n * @private\n */\nclass ExponentialBackoff {\n    constructor(options = {}) {\n        /**\n         * The number of retries that has been attempted.\n         *\n         * @private\n         */\n        this._retryCount = 0;\n        /**\n         * The backoff delay of the current attempt.\n         *\n         * @private\n         */\n        this.currentBaseMs = 0;\n        /**\n         * Whether we are currently waiting for backoff to complete.\n         *\n         * @private\n         */\n        this.awaitingBackoffCompletion = false;\n        this.initialDelayMs =\n            options.initialDelayMs !== undefined\n                ? options.initialDelayMs\n                : DEFAULT_BACKOFF_INITIAL_DELAY_MS;\n        this.backoffFactor =\n            options.backoffFactor !== undefined\n                ? options.backoffFactor\n                : DEFAULT_BACKOFF_FACTOR;\n        this.maxDelayMs =\n            options.maxDelayMs !== undefined\n                ? options.maxDelayMs\n                : DEFAULT_BACKOFF_MAX_DELAY_MS;\n        this.jitterFactor =\n            options.jitterFactor !== undefined\n                ? options.jitterFactor\n                : DEFAULT_JITTER_FACTOR;\n    }\n    /**\n     * Resets the backoff delay and retry count.\n     *\n     * The very next backoffAndWait() will have no delay. If it is called again\n     * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\n     * subsequent ones will increase according to the backoffFactor.\n     *\n     * @private\n     */\n    reset() {\n        this._retryCount = 0;\n        this.currentBaseMs = 0;\n    }\n    /**\n     * Resets the backoff delay to the maximum delay (e.g. for use after a\n     * RESOURCE_EXHAUSTED error).\n     *\n     * @private\n     */\n    resetToMax() {\n        this.currentBaseMs = this.maxDelayMs;\n    }\n    /**\n     * Returns a promise that resolves after currentDelayMs, and increases the\n     * delay for any subsequent attempts.\n     *\n     * @return A Promise that resolves when the current delay elapsed.\n     * @private\n     */\n    backoffAndWait() {\n        if (this.awaitingBackoffCompletion) {\n            return Promise.reject(new Error('A backoff operation is already in progress.'));\n        }\n        if (this.retryCount > exports.MAX_RETRY_ATTEMPTS) {\n            return Promise.reject(new Error('Exceeded maximum number of retries allowed.'));\n        }\n        // First schedule using the current base (which may be 0 and should be\n        // honored as such).\n        const delayWithJitterMs = this.currentBaseMs + this.jitterDelayMs();\n        if (this.currentBaseMs > 0) {\n            logger_1.logger('ExponentialBackoff.backoffAndWait', null, `Backing off for ${delayWithJitterMs} ms ` +\n                `(base delay: ${this.currentBaseMs} ms)`);\n        }\n        // Apply backoff factor to determine next delay and ensure it is within\n        // bounds.\n        this.currentBaseMs *= this.backoffFactor;\n        this.currentBaseMs = Math.max(this.currentBaseMs, this.initialDelayMs);\n        this.currentBaseMs = Math.min(this.currentBaseMs, this.maxDelayMs);\n        this._retryCount += 1;\n        return new Promise(resolve => {\n            this.awaitingBackoffCompletion = true;\n            exports.delayExecution(() => {\n                this.awaitingBackoffCompletion = false;\n                resolve();\n            }, delayWithJitterMs);\n        });\n    }\n    // Visible for testing.\n    get retryCount() {\n        return this._retryCount;\n    }\n    /**\n     * Returns a randomized \"jitter\" delay based on the current base and jitter\n     * factor.\n     *\n     * @returns {number} The jitter to apply based on the current delay.\n     * @private\n     */\n    jitterDelayMs() {\n        return (Math.random() - 0.5) * this.jitterFactor * this.currentBaseMs;\n    }\n}\nexports.ExponentialBackoff = ExponentialBackoff;\n//# sourceMappingURL=backoff.js.map"]},"metadata":{},"sourceType":"script"}