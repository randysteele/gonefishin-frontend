{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/randysteele/gone-fishin/gone-fishin-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/randysteele/gone-fishin/gone-fishin-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/randysteele/gone-fishin/gone-fishin-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/randysteele/gone-fishin/gone-fishin-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar google_gax_1 = require(\"google-gax\");\n\nvar assert = require(\"assert\");\n\nvar backoff_1 = require(\"./backoff\");\n\nvar rate_limiter_1 = require(\"./rate-limiter\");\n\nvar util_1 = require(\"./util\");\n\nvar write_batch_1 = require(\"./write-batch\");\n\nvar logger_1 = require(\"./logger\");\n\nvar validate_1 = require(\"./validate\");\n/*!\n * The maximum number of writes that can be in a single batch.\n */\n\n\nvar MAX_BATCH_SIZE = 20;\n/*!\n * The starting maximum number of operations per second as allowed by the\n * 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\n\nexports.DEFAULT_STARTING_MAXIMUM_OPS_PER_SECOND = 500;\n/*!\n * The rate by which to increase the capacity as specified by the 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\n\nvar RATE_LIMITER_MULTIPLIER = 1.5;\n/*!\n * How often the operations per second capacity should increase in milliseconds\n * as specified by the 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\n\nvar RATE_LIMITER_MULTIPLIER_MILLIS = 5 * 60 * 1000;\n/*!\n * Used to represent the state of batch.\n *\n * Writes can only be added while the batch is OPEN. For a batch to be sent,\n * the batch must be READY_TO_SEND. After a batch is sent, it is marked as SENT.\n */\n\nvar BatchState;\n\n(function (BatchState) {\n  BatchState[BatchState[\"OPEN\"] = 0] = \"OPEN\";\n  BatchState[BatchState[\"READY_TO_SEND\"] = 1] = \"READY_TO_SEND\";\n  BatchState[BatchState[\"SENT\"] = 2] = \"SENT\";\n})(BatchState || (BatchState = {}));\n/**\n * Used to represent a batch on the BatchQueue.\n *\n * @private\n */\n\n\nvar BulkCommitBatch = /*#__PURE__*/function () {\n  function BulkCommitBatch(firestore, writeBatch, maxBatchSize) {\n    _classCallCheck(this, BulkCommitBatch);\n\n    this.firestore = firestore;\n    this.writeBatch = writeBatch;\n    this.maxBatchSize = maxBatchSize;\n    /**\n     * The state of the batch.\n     */\n\n    this.state = BatchState.OPEN; // A deferred promise that is resolved after the batch has been sent, and a\n    // response is received.\n\n    this.completedDeferred = new util_1.Deferred(); // An array of pending write operations. Only contains writes that have not\n    // been resolved.\n\n    this.pendingOps = [];\n    this.backoff = new backoff_1.ExponentialBackoff();\n  }\n  /**\n   * The number of writes in this batch.\n   */\n\n\n  _createClass(BulkCommitBatch, [{\n    key: \"create\",\n\n    /**\n     * Adds a `create` operation to the WriteBatch. Returns a promise that\n     * resolves with the result of the write.\n     */\n    value: function create(documentRef, data) {\n      this.writeBatch.create(documentRef, data);\n      return this.processOperation(documentRef);\n    }\n    /**\n     * Adds a `delete` operation to the WriteBatch. Returns a promise that\n     * resolves with the sentinel value (Timestamp(0)) for the delete operation.\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(documentRef, precondition) {\n      this.writeBatch.delete(documentRef, precondition);\n      return this.processOperation(documentRef);\n    }\n    /**\n     * Adds a `set` operation to the WriteBatch. Returns a promise that\n     * resolves with the result of the write.\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(documentRef, data, options) {\n      this.writeBatch.set(documentRef, data, options);\n      return this.processOperation(documentRef);\n    }\n    /**\n     * Adds an `update` operation to the WriteBatch. Returns a promise that\n     * resolves with the result of the write.\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(documentRef, dataOrField) {\n      var _this$writeBatch;\n\n      for (var _len = arguments.length, preconditionOrValues = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        preconditionOrValues[_key - 2] = arguments[_key];\n      }\n\n      (_this$writeBatch = this.writeBatch).update.apply(_this$writeBatch, [documentRef, dataOrField].concat(preconditionOrValues));\n\n      return this.processOperation(documentRef);\n    }\n    /**\n     * Helper to update data structures associated with the operation and\n     * return the result.\n     */\n\n  }, {\n    key: \"processOperation\",\n    value: function processOperation(documentRef) {\n      assert(this.state === BatchState.OPEN, 'Batch should be OPEN when adding writes');\n      var deferred = new util_1.Deferred();\n      this.pendingOps.push({\n        writeBatchIndex: this.opCount,\n        key: documentRef.path,\n        deferred: deferred\n      });\n\n      if (this.opCount === this.maxBatchSize) {\n        this.state = BatchState.READY_TO_SEND;\n      }\n\n      return deferred.promise.then(function (result) {\n        if (result.writeTime) {\n          return new write_batch_1.WriteResult(result.writeTime);\n        } else {\n          throw result.status;\n        }\n      });\n    }\n    /**\n     * Commits the batch and returns a promise that resolves when all the writes\n     * in the batch have finished.\n     *\n     * If any writes in the batch fail with a retryable error, this method will\n     * retry the failed writes.\n     */\n\n  }, {\n    key: \"bulkCommit\",\n    value: function () {\n      var _bulkCommit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var stack, results, attempt;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                assert(this.state === BatchState.READY_TO_SEND, 'The batch should be marked as READY_TO_SEND before committing');\n                this.state = BatchState.SENT; // Capture the error stack to preserve stack tracing across async calls.\n\n                stack = Error().stack;\n                results = [];\n                attempt = 0;\n\n              case 5:\n                if (!(attempt < backoff_1.MAX_RETRY_ATTEMPTS)) {\n                  _context.next = 28;\n                  break;\n                }\n\n                _context.next = 8;\n                return this.backoff.backoffAndWait();\n\n              case 8:\n                _context.prev = 8;\n                _context.next = 11;\n                return this.writeBatch.bulkCommit();\n\n              case 11:\n                results = _context.sent;\n                _context.next = 17;\n                break;\n\n              case 14:\n                _context.prev = 14;\n                _context.t0 = _context[\"catch\"](8);\n                // Map the failure to each individual write's result.\n                results = this.pendingOps.map(function (op) {\n                  return {\n                    key: op.key,\n                    writeTime: null,\n                    status: util_1.wrapError(_context.t0, stack)\n                  };\n                });\n\n              case 17:\n                this.processResults(results,\n                /* allowRetry= */\n                true);\n\n                if (!(this.pendingOps.length > 0)) {\n                  _context.next = 23;\n                  break;\n                }\n\n                logger_1.logger('BulkWriter.bulkCommit', null, \"Current batch failed at retry #\".concat(attempt, \". Num failures: \") + \"\".concat(this.pendingOps.length, \".\"));\n                this.writeBatch = new write_batch_1.WriteBatch(this.firestore, this.writeBatch, new Set(this.pendingOps.map(function (op) {\n                  return op.writeBatchIndex;\n                })));\n                _context.next = 25;\n                break;\n\n              case 23:\n                this.completedDeferred.resolve();\n                return _context.abrupt(\"return\");\n\n              case 25:\n                attempt++;\n                _context.next = 5;\n                break;\n\n              case 28:\n                this.processResults(results);\n                this.completedDeferred.resolve();\n\n              case 30:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[8, 14]]);\n      }));\n\n      function bulkCommit() {\n        return _bulkCommit.apply(this, arguments);\n      }\n\n      return bulkCommit;\n    }()\n    /**\n     * Resolves the individual operations in the batch with the results.\n     */\n\n  }, {\n    key: \"processResults\",\n    value: function processResults(results) {\n      var allowRetry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var newPendingOps = [];\n\n      for (var i = 0; i < results.length; i++) {\n        var result = results[i];\n        var op = this.pendingOps[i];\n\n        if (result.status.code === google_gax_1.Status.OK) {\n          op.deferred.resolve(result);\n        } else if (!allowRetry || !this.shouldRetry(result.status.code)) {\n          op.deferred.reject(result.status);\n        } else {\n          // Retry the operation if it has not been processed.\n          // Store the current index of pendingOps to preserve the mapping of\n          // this operation's index in the underlying WriteBatch.\n          newPendingOps.push({\n            writeBatchIndex: i,\n            key: op.key,\n            deferred: op.deferred\n          });\n        }\n      }\n\n      this.pendingOps = newPendingOps;\n    }\n  }, {\n    key: \"shouldRetry\",\n    value: function shouldRetry(code) {\n      var retryCodes = util_1.getRetryCodes('batchWrite');\n      return code !== undefined && retryCodes.includes(code);\n    }\n    /**\n     * Returns a promise that resolves when the batch has been sent, and a\n     * response is received.\n     */\n\n  }, {\n    key: \"awaitBulkCommit\",\n    value: function awaitBulkCommit() {\n      this.markReadyToSend();\n      return this.completedDeferred.promise;\n    }\n  }, {\n    key: \"markReadyToSend\",\n    value: function markReadyToSend() {\n      if (this.state === BatchState.OPEN) {\n        this.state = BatchState.READY_TO_SEND;\n      }\n    }\n  }, {\n    key: \"opCount\",\n    get: function get() {\n      return this.pendingOps.length;\n    }\n  }]);\n\n  return BulkCommitBatch;\n}();\n/**\n * A Firestore BulkWriter than can be used to perform a large number of writes\n * in parallel. Writes to the same document will be executed sequentially.\n *\n * @class\n */\n\n\nvar BulkWriter = /*#__PURE__*/function () {\n  function BulkWriter(firestore, options) {\n    _classCallCheck(this, BulkWriter);\n\n    var _a, _b;\n\n    this.firestore = firestore;\n    /**\n     * The maximum number of writes that can be in a single batch.\n     */\n\n    this.maxBatchSize = MAX_BATCH_SIZE;\n    /**\n     * A queue of batches to be written.\n     */\n\n    this.batchQueue = [];\n    /**\n     * Whether this BulkWriter instance is closed. Once closed, it cannot be\n     * opened again.\n     */\n\n    this.closed = false;\n\n    this.firestore._incrementBulkWritersCount();\n\n    validateBulkWriterOptions(options);\n\n    if ((options === null || options === void 0 ? void 0 : options.throttling) === false) {\n      this.rateLimiter = new rate_limiter_1.RateLimiter(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n    } else {\n      var startingRate = exports.DEFAULT_STARTING_MAXIMUM_OPS_PER_SECOND;\n      var maxRate = Number.POSITIVE_INFINITY;\n\n      if (typeof (options === null || options === void 0 ? void 0 : options.throttling) !== 'boolean') {\n        if (((_a = options === null || options === void 0 ? void 0 : options.throttling) === null || _a === void 0 ? void 0 : _a.maxOpsPerSecond) !== undefined) {\n          maxRate = options.throttling.maxOpsPerSecond;\n        }\n\n        if (((_b = options === null || options === void 0 ? void 0 : options.throttling) === null || _b === void 0 ? void 0 : _b.initialOpsPerSecond) !== undefined) {\n          startingRate = options.throttling.initialOpsPerSecond;\n        } // The initial validation step ensures that the maxOpsPerSecond is\n        // greater than initialOpsPerSecond. If this inequality is true, that\n        // means initialOpsPerSecond was not set and maxOpsPerSecond is less\n        // than the default starting rate.\n\n\n        if (maxRate < startingRate) {\n          startingRate = maxRate;\n        } // Ensure that the batch size is not larger than the number of allowed\n        // operations per second.\n\n\n        if (startingRate < this.maxBatchSize) {\n          this.maxBatchSize = startingRate;\n        }\n      }\n\n      this.rateLimiter = new rate_limiter_1.RateLimiter(startingRate, RATE_LIMITER_MULTIPLIER, RATE_LIMITER_MULTIPLIER_MILLIS, maxRate);\n    }\n  }\n  /**\n   * Create a document with the provided data. This single operation will fail\n   * if a document exists at its location.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * created.\n   * @param {T} data The object to serialize as the document.\n   * @returns {Promise<WriteResult>} A promise that resolves with the result of\n   * the write. Throws an error if the write fails.\n   *\n   * @example\n   * let bulkWriter = firestore.bulkWriter();\n   * let documentRef = firestore.collection('col').doc();\n   *\n   * bulkWriter\n   *  .create(documentRef, {foo: 'bar'})\n   *  .then(result => {\n   *    console.log('Successfully executed write at: ', result);\n   *  })\n   *  .catch(err => {\n   *    console.log('Write failed with: ', err);\n   *  });\n   * });\n   */\n\n\n  _createClass(BulkWriter, [{\n    key: \"create\",\n    value: function create(documentRef, data) {\n      this.verifyNotClosed();\n      var bulkCommitBatch = this.getEligibleBatch();\n      var resultPromise = bulkCommitBatch.create(documentRef, data);\n      this.sendReadyBatches();\n      return resultPromise;\n    }\n    /**\n     * Delete a document from the database.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * deleted.\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the batch if the\n     * document doesn't exist or was last updated at a different time.\n     * @returns {Promise<WriteResult>} A promise that resolves with a sentinel\n     * Timestamp indicating that the delete was successful. Throws an error if\n     * the write fails.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * bulkWriter\n     *  .delete(documentRef)\n     *  .then(result => {\n     *    console.log('Successfully deleted document');\n     *  })\n     *  .catch(err => {\n     *    console.log('Delete failed with: ', err);\n     *  });\n     * });\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(documentRef, precondition) {\n      this.verifyNotClosed();\n      var bulkCommitBatch = this.getEligibleBatch();\n      var resultPromise = bulkCommitBatch.delete(documentRef, precondition);\n      this.sendReadyBatches();\n      return resultPromise;\n    }\n    /**\n     * Write to the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document does not\n     * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions}.,\n     * the provided data can be merged into the existing document.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * set.\n     * @param {T} data The object to serialize as the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge - If true, set() merges the values\n     * specified in its data argument. Fields omitted from this set() call remain\n     * untouched.\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided, set()\n     * only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched.\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. Throws an error if the write fails.\n     *\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * bulkWriter\n     *  .set(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(documentRef, data, options) {\n      this.verifyNotClosed();\n      var bulkCommitBatch = this.getEligibleBatch();\n      var resultPromise = bulkCommitBatch.set(documentRef, data, options);\n      this.sendReadyBatches();\n      return resultPromise;\n    }\n    /**\n     * Update fields of the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document doesn't yet\n     * exist, the update fails and the entire batch will be rejected.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values. Nested fields can be\n     * updated by providing dot-separated field path strings or by providing\n     * FieldPath objects.\n     *\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * updated.\n     * @param {UpdateData|string|FieldPath} dataOrField An object containing the\n     * fields and values with which to update the document or the path of the\n     * first field to update.\n     * @param {...(Precondition|*|string|FieldPath)} preconditionOrValues - An\n     * alternating list of field paths and values to update or a Precondition to\n     * restrict this update\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. Throws an error if the write fails.\n     *\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * bulkWriter\n     *  .update(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(documentRef, dataOrField) {\n      this.verifyNotClosed();\n      var bulkCommitBatch = this.getEligibleBatch();\n\n      for (var _len2 = arguments.length, preconditionOrValues = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        preconditionOrValues[_key2 - 2] = arguments[_key2];\n      }\n\n      var resultPromise = bulkCommitBatch.update.apply(bulkCommitBatch, [documentRef, dataOrField].concat(preconditionOrValues));\n      this.sendReadyBatches();\n      return resultPromise;\n    }\n    /**\n     * Commits all writes that have been enqueued up to this point in parallel.\n     *\n     * Returns a Promise that resolves when all currently queued operations have\n     * been committed. The Promise will never be rejected since the results for\n     * each individual operation are conveyed via their individual Promises.\n     *\n     * The Promise resolves immediately if there are no pending writes. Otherwise,\n     * the Promise waits for all previously issued writes, but it does not wait\n     * for writes that were added after the method is called. If you want to wait\n     * for additional writes, call `flush()` again.\n     *\n     * @return {Promise<void>} A promise that resolves when all enqueued writes\n     * up to this point have been committed.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter.create(documentRef, {foo: 'bar'});\n     * bulkWriter.update(documentRef2, {foo: 'bar'});\n     * bulkWriter.delete(documentRef3);\n     * await flush().then(() => {\n     *   console.log('Executed all writes');\n     * });\n     */\n\n  }, {\n    key: \"flush\",\n    value: function () {\n      var _flush = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var trackedBatches, writePromises;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this.verifyNotClosed();\n                trackedBatches = this.batchQueue;\n                writePromises = trackedBatches.map(function (batch) {\n                  return batch.awaitBulkCommit();\n                });\n                this.sendReadyBatches();\n                _context2.next = 6;\n                return Promise.all(writePromises);\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function flush() {\n        return _flush.apply(this, arguments);\n      }\n\n      return flush;\n    }()\n    /**\n     * Commits all enqueued writes and marks the BulkWriter instance as closed.\n     *\n     * After calling `close()`, calling any method wil throw an error.\n     *\n     * Returns a Promise that resolves when there are no more pending writes. The\n     * Promise will never be rejected. Calling this method will send all requests.\n     * The promise resolves immediately if there are no pending writes.\n     *\n     * @return {Promise<void>} A promise that resolves when all enqueued writes\n     * up to this point have been committed.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter.create(documentRef, {foo: 'bar'});\n     * bulkWriter.update(documentRef2, {foo: 'bar'});\n     * bulkWriter.delete(documentRef3);\n     * await close().then(() => {\n     *   console.log('Executed all writes');\n     * });\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      this.verifyNotClosed();\n\n      this.firestore._decrementBulkWritersCount();\n\n      var flushPromise = this.flush();\n      this.closed = true;\n      return flushPromise;\n    }\n  }, {\n    key: \"verifyNotClosed\",\n    value: function verifyNotClosed() {\n      if (this.closed) {\n        throw new Error('BulkWriter has already been closed.');\n      }\n    }\n    /**\n     * Return the first eligible batch that can hold a write to the provided\n     * reference, or creates one if no eligible batches are found.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"getEligibleBatch\",\n    value: function getEligibleBatch() {\n      if (this.batchQueue.length > 0) {\n        var lastBatch = this.batchQueue[this.batchQueue.length - 1];\n\n        if (lastBatch.state === BatchState.OPEN) {\n          return lastBatch;\n        }\n      }\n\n      return this.createNewBatch();\n    }\n    /**\n     * Creates a new batch and adds it to the BatchQueue. If there is already a\n     * batch enqueued, sends the batch after a new one is created.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"createNewBatch\",\n    value: function createNewBatch() {\n      var newBatch = new BulkCommitBatch(this.firestore, this.firestore.batch(), this.maxBatchSize);\n\n      if (this.batchQueue.length > 0) {\n        this.batchQueue[this.batchQueue.length - 1].markReadyToSend();\n        this.sendReadyBatches();\n      }\n\n      this.batchQueue.push(newBatch);\n      return newBatch;\n    }\n    /**\n     * Attempts to send batches starting from the front of the BatchQueue until a\n     * batch cannot be sent.\n     *\n     * After a batch is complete, try sending batches again.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"sendReadyBatches\",\n    value: function sendReadyBatches() {\n      var _this = this;\n\n      var unsentBatches = this.batchQueue.filter(function (batch) {\n        return batch.state === BatchState.READY_TO_SEND;\n      });\n      var index = 0;\n\n      while (index < unsentBatches.length && unsentBatches[index].state === BatchState.READY_TO_SEND) {\n        var batch = unsentBatches[index]; // Send the batch if it is under the rate limit, or schedule another\n        // attempt after the appropriate timeout.\n\n        var delayMs = this.rateLimiter.getNextRequestDelayMs(batch.opCount);\n        assert(delayMs !== -1, 'Batch size should be under capacity');\n\n        if (delayMs === 0) {\n          this.sendBatch(batch);\n        } else {\n          backoff_1.delayExecution(function () {\n            return _this.sendReadyBatches();\n          }, delayMs);\n          break;\n        }\n\n        index++;\n      }\n    }\n    /**\n     * Sends the provided batch and processes the results. After the batch is\n     * committed, sends the next group of ready batches.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"sendBatch\",\n    value: function sendBatch(batch) {\n      var _this2 = this;\n\n      var success = this.rateLimiter.tryMakeRequest(batch.opCount);\n      assert(success, 'Batch should be under rate limit to be sent.');\n      batch.bulkCommit().then(function () {\n        // Remove the batch from the BatchQueue after it has been processed.\n        var batchIndex = _this2.batchQueue.indexOf(batch);\n\n        assert(batchIndex !== -1, 'The batch should be in the BatchQueue');\n\n        _this2.batchQueue.splice(batchIndex, 1);\n\n        _this2.sendReadyBatches();\n      });\n    }\n    /**\n     * Sets the maximum number of allowed operations in a batch.\n     *\n     * @private\n     */\n    // Visible for testing.\n\n  }, {\n    key: \"_setMaxBatchSize\",\n    value: function _setMaxBatchSize(size) {\n      this.maxBatchSize = size;\n    }\n    /**\n     * Returns the rate limiter for testing.\n     *\n     * @private\n     */\n    // Visible for testing.\n\n  }, {\n    key: \"_getRateLimiter\",\n    value: function _getRateLimiter() {\n      return this.rateLimiter;\n    }\n  }]);\n\n  return BulkWriter;\n}();\n\nexports.BulkWriter = BulkWriter;\n/**\n * Validates the use of 'value' as BulkWriterOptions.\n *\n * @private\n * @param value The BulkWriterOptions object to validate.\n * @throws if the input is not a valid BulkWriterOptions object.\n */\n\nfunction validateBulkWriterOptions(value) {\n  if (validate_1.validateOptional(value, {\n    optional: true\n  })) {\n    return;\n  }\n\n  var argName = 'options';\n\n  if (!util_1.isObject(value)) {\n    throw new Error(\"\".concat(validate_1.invalidArgumentMessage(argName, 'bulkWriter() options argument'), \" Input is not an object.\"));\n  }\n\n  var options = value;\n\n  if (options.throttling === undefined || typeof options.throttling === 'boolean') {\n    return;\n  }\n\n  if (options.throttling.initialOpsPerSecond !== undefined) {\n    validate_1.validateInteger('initialOpsPerSecond', options.throttling.initialOpsPerSecond, {\n      minValue: 1\n    });\n  }\n\n  if (options.throttling.maxOpsPerSecond !== undefined) {\n    validate_1.validateInteger('maxOpsPerSecond', options.throttling.maxOpsPerSecond, {\n      minValue: 1\n    });\n\n    if (options.throttling.initialOpsPerSecond !== undefined && options.throttling.initialOpsPerSecond > options.throttling.maxOpsPerSecond) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(argName, 'bulkWriter() options argument'), \" \\\"maxOpsPerSecond\\\" cannot be less than \\\"initialOpsPerSecond\\\".\"));\n    }\n  }\n}","map":{"version":3,"sources":["/Users/randysteele/gone-fishin/gone-fishin-frontend/node_modules/@google-cloud/firestore/build/src/bulk-writer.js"],"names":["Object","defineProperty","exports","value","google_gax_1","require","assert","backoff_1","rate_limiter_1","util_1","write_batch_1","logger_1","validate_1","MAX_BATCH_SIZE","DEFAULT_STARTING_MAXIMUM_OPS_PER_SECOND","RATE_LIMITER_MULTIPLIER","RATE_LIMITER_MULTIPLIER_MILLIS","BatchState","BulkCommitBatch","firestore","writeBatch","maxBatchSize","state","OPEN","completedDeferred","Deferred","pendingOps","backoff","ExponentialBackoff","documentRef","data","create","processOperation","precondition","delete","options","set","dataOrField","preconditionOrValues","update","deferred","push","writeBatchIndex","opCount","key","path","READY_TO_SEND","promise","then","result","writeTime","WriteResult","status","SENT","stack","Error","results","attempt","MAX_RETRY_ATTEMPTS","backoffAndWait","bulkCommit","map","op","wrapError","processResults","length","logger","WriteBatch","Set","resolve","allowRetry","newPendingOps","i","code","Status","OK","shouldRetry","reject","retryCodes","getRetryCodes","undefined","includes","markReadyToSend","BulkWriter","_a","_b","batchQueue","closed","_incrementBulkWritersCount","validateBulkWriterOptions","throttling","rateLimiter","RateLimiter","Number","POSITIVE_INFINITY","startingRate","maxRate","maxOpsPerSecond","initialOpsPerSecond","verifyNotClosed","bulkCommitBatch","getEligibleBatch","resultPromise","sendReadyBatches","trackedBatches","writePromises","batch","awaitBulkCommit","Promise","all","_decrementBulkWritersCount","flushPromise","flush","lastBatch","createNewBatch","newBatch","unsentBatches","filter","index","delayMs","getNextRequestDelayMs","sendBatch","delayExecution","success","tryMakeRequest","batchIndex","indexOf","splice","size","validateOptional","optional","argName","isObject","invalidArgumentMessage","validateInteger","minValue"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst google_gax_1 = require(\"google-gax\");\nconst assert = require(\"assert\");\nconst backoff_1 = require(\"./backoff\");\nconst rate_limiter_1 = require(\"./rate-limiter\");\nconst util_1 = require(\"./util\");\nconst write_batch_1 = require(\"./write-batch\");\nconst logger_1 = require(\"./logger\");\nconst validate_1 = require(\"./validate\");\n/*!\n * The maximum number of writes that can be in a single batch.\n */\nconst MAX_BATCH_SIZE = 20;\n/*!\n * The starting maximum number of operations per second as allowed by the\n * 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\nexports.DEFAULT_STARTING_MAXIMUM_OPS_PER_SECOND = 500;\n/*!\n * The rate by which to increase the capacity as specified by the 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\nconst RATE_LIMITER_MULTIPLIER = 1.5;\n/*!\n * How often the operations per second capacity should increase in milliseconds\n * as specified by the 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\nconst RATE_LIMITER_MULTIPLIER_MILLIS = 5 * 60 * 1000;\n/*!\n * Used to represent the state of batch.\n *\n * Writes can only be added while the batch is OPEN. For a batch to be sent,\n * the batch must be READY_TO_SEND. After a batch is sent, it is marked as SENT.\n */\nvar BatchState;\n(function (BatchState) {\n    BatchState[BatchState[\"OPEN\"] = 0] = \"OPEN\";\n    BatchState[BatchState[\"READY_TO_SEND\"] = 1] = \"READY_TO_SEND\";\n    BatchState[BatchState[\"SENT\"] = 2] = \"SENT\";\n})(BatchState || (BatchState = {}));\n/**\n * Used to represent a batch on the BatchQueue.\n *\n * @private\n */\nclass BulkCommitBatch {\n    constructor(firestore, writeBatch, maxBatchSize) {\n        this.firestore = firestore;\n        this.writeBatch = writeBatch;\n        this.maxBatchSize = maxBatchSize;\n        /**\n         * The state of the batch.\n         */\n        this.state = BatchState.OPEN;\n        // A deferred promise that is resolved after the batch has been sent, and a\n        // response is received.\n        this.completedDeferred = new util_1.Deferred();\n        // An array of pending write operations. Only contains writes that have not\n        // been resolved.\n        this.pendingOps = [];\n        this.backoff = new backoff_1.ExponentialBackoff();\n    }\n    /**\n     * The number of writes in this batch.\n     */\n    get opCount() {\n        return this.pendingOps.length;\n    }\n    /**\n     * Adds a `create` operation to the WriteBatch. Returns a promise that\n     * resolves with the result of the write.\n     */\n    create(documentRef, data) {\n        this.writeBatch.create(documentRef, data);\n        return this.processOperation(documentRef);\n    }\n    /**\n     * Adds a `delete` operation to the WriteBatch. Returns a promise that\n     * resolves with the sentinel value (Timestamp(0)) for the delete operation.\n     */\n    delete(documentRef, precondition) {\n        this.writeBatch.delete(documentRef, precondition);\n        return this.processOperation(documentRef);\n    }\n    /**\n     * Adds a `set` operation to the WriteBatch. Returns a promise that\n     * resolves with the result of the write.\n     */\n    set(documentRef, data, options) {\n        this.writeBatch.set(documentRef, data, options);\n        return this.processOperation(documentRef);\n    }\n    /**\n     * Adds an `update` operation to the WriteBatch. Returns a promise that\n     * resolves with the result of the write.\n     */\n    update(documentRef, dataOrField, ...preconditionOrValues) {\n        this.writeBatch.update(documentRef, dataOrField, ...preconditionOrValues);\n        return this.processOperation(documentRef);\n    }\n    /**\n     * Helper to update data structures associated with the operation and\n     * return the result.\n     */\n    processOperation(documentRef) {\n        assert(this.state === BatchState.OPEN, 'Batch should be OPEN when adding writes');\n        const deferred = new util_1.Deferred();\n        this.pendingOps.push({\n            writeBatchIndex: this.opCount,\n            key: documentRef.path,\n            deferred: deferred,\n        });\n        if (this.opCount === this.maxBatchSize) {\n            this.state = BatchState.READY_TO_SEND;\n        }\n        return deferred.promise.then(result => {\n            if (result.writeTime) {\n                return new write_batch_1.WriteResult(result.writeTime);\n            }\n            else {\n                throw result.status;\n            }\n        });\n    }\n    /**\n     * Commits the batch and returns a promise that resolves when all the writes\n     * in the batch have finished.\n     *\n     * If any writes in the batch fail with a retryable error, this method will\n     * retry the failed writes.\n     */\n    async bulkCommit() {\n        assert(this.state === BatchState.READY_TO_SEND, 'The batch should be marked as READY_TO_SEND before committing');\n        this.state = BatchState.SENT;\n        // Capture the error stack to preserve stack tracing across async calls.\n        const stack = Error().stack;\n        let results = [];\n        for (let attempt = 0; attempt < backoff_1.MAX_RETRY_ATTEMPTS; attempt++) {\n            await this.backoff.backoffAndWait();\n            try {\n                results = await this.writeBatch.bulkCommit();\n            }\n            catch (err) {\n                // Map the failure to each individual write's result.\n                results = this.pendingOps.map(op => {\n                    return { key: op.key, writeTime: null, status: util_1.wrapError(err, stack) };\n                });\n            }\n            this.processResults(results, /* allowRetry= */ true);\n            if (this.pendingOps.length > 0) {\n                logger_1.logger('BulkWriter.bulkCommit', null, `Current batch failed at retry #${attempt}. Num failures: ` +\n                    `${this.pendingOps.length}.`);\n                this.writeBatch = new write_batch_1.WriteBatch(this.firestore, this.writeBatch, new Set(this.pendingOps.map(op => op.writeBatchIndex)));\n            }\n            else {\n                this.completedDeferred.resolve();\n                return;\n            }\n        }\n        this.processResults(results);\n        this.completedDeferred.resolve();\n    }\n    /**\n     * Resolves the individual operations in the batch with the results.\n     */\n    processResults(results, allowRetry = false) {\n        const newPendingOps = [];\n        for (let i = 0; i < results.length; i++) {\n            const result = results[i];\n            const op = this.pendingOps[i];\n            if (result.status.code === google_gax_1.Status.OK) {\n                op.deferred.resolve(result);\n            }\n            else if (!allowRetry || !this.shouldRetry(result.status.code)) {\n                op.deferred.reject(result.status);\n            }\n            else {\n                // Retry the operation if it has not been processed.\n                // Store the current index of pendingOps to preserve the mapping of\n                // this operation's index in the underlying WriteBatch.\n                newPendingOps.push({\n                    writeBatchIndex: i,\n                    key: op.key,\n                    deferred: op.deferred,\n                });\n            }\n        }\n        this.pendingOps = newPendingOps;\n    }\n    shouldRetry(code) {\n        const retryCodes = util_1.getRetryCodes('batchWrite');\n        return code !== undefined && retryCodes.includes(code);\n    }\n    /**\n     * Returns a promise that resolves when the batch has been sent, and a\n     * response is received.\n     */\n    awaitBulkCommit() {\n        this.markReadyToSend();\n        return this.completedDeferred.promise;\n    }\n    markReadyToSend() {\n        if (this.state === BatchState.OPEN) {\n            this.state = BatchState.READY_TO_SEND;\n        }\n    }\n}\n/**\n * A Firestore BulkWriter than can be used to perform a large number of writes\n * in parallel. Writes to the same document will be executed sequentially.\n *\n * @class\n */\nclass BulkWriter {\n    constructor(firestore, options) {\n        var _a, _b;\n        this.firestore = firestore;\n        /**\n         * The maximum number of writes that can be in a single batch.\n         */\n        this.maxBatchSize = MAX_BATCH_SIZE;\n        /**\n         * A queue of batches to be written.\n         */\n        this.batchQueue = [];\n        /**\n         * Whether this BulkWriter instance is closed. Once closed, it cannot be\n         * opened again.\n         */\n        this.closed = false;\n        this.firestore._incrementBulkWritersCount();\n        validateBulkWriterOptions(options);\n        if ((options === null || options === void 0 ? void 0 : options.throttling) === false) {\n            this.rateLimiter = new rate_limiter_1.RateLimiter(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n        }\n        else {\n            let startingRate = exports.DEFAULT_STARTING_MAXIMUM_OPS_PER_SECOND;\n            let maxRate = Number.POSITIVE_INFINITY;\n            if (typeof (options === null || options === void 0 ? void 0 : options.throttling) !== 'boolean') {\n                if (((_a = options === null || options === void 0 ? void 0 : options.throttling) === null || _a === void 0 ? void 0 : _a.maxOpsPerSecond) !== undefined) {\n                    maxRate = options.throttling.maxOpsPerSecond;\n                }\n                if (((_b = options === null || options === void 0 ? void 0 : options.throttling) === null || _b === void 0 ? void 0 : _b.initialOpsPerSecond) !== undefined) {\n                    startingRate = options.throttling.initialOpsPerSecond;\n                }\n                // The initial validation step ensures that the maxOpsPerSecond is\n                // greater than initialOpsPerSecond. If this inequality is true, that\n                // means initialOpsPerSecond was not set and maxOpsPerSecond is less\n                // than the default starting rate.\n                if (maxRate < startingRate) {\n                    startingRate = maxRate;\n                }\n                // Ensure that the batch size is not larger than the number of allowed\n                // operations per second.\n                if (startingRate < this.maxBatchSize) {\n                    this.maxBatchSize = startingRate;\n                }\n            }\n            this.rateLimiter = new rate_limiter_1.RateLimiter(startingRate, RATE_LIMITER_MULTIPLIER, RATE_LIMITER_MULTIPLIER_MILLIS, maxRate);\n        }\n    }\n    /**\n     * Create a document with the provided data. This single operation will fail\n     * if a document exists at its location.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * created.\n     * @param {T} data The object to serialize as the document.\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. Throws an error if the write fails.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * bulkWriter\n     *  .create(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n    create(documentRef, data) {\n        this.verifyNotClosed();\n        const bulkCommitBatch = this.getEligibleBatch();\n        const resultPromise = bulkCommitBatch.create(documentRef, data);\n        this.sendReadyBatches();\n        return resultPromise;\n    }\n    /**\n     * Delete a document from the database.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * deleted.\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the batch if the\n     * document doesn't exist or was last updated at a different time.\n     * @returns {Promise<WriteResult>} A promise that resolves with a sentinel\n     * Timestamp indicating that the delete was successful. Throws an error if\n     * the write fails.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * bulkWriter\n     *  .delete(documentRef)\n     *  .then(result => {\n     *    console.log('Successfully deleted document');\n     *  })\n     *  .catch(err => {\n     *    console.log('Delete failed with: ', err);\n     *  });\n     * });\n     */\n    delete(documentRef, precondition) {\n        this.verifyNotClosed();\n        const bulkCommitBatch = this.getEligibleBatch();\n        const resultPromise = bulkCommitBatch.delete(documentRef, precondition);\n        this.sendReadyBatches();\n        return resultPromise;\n    }\n    /**\n     * Write to the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document does not\n     * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions}.,\n     * the provided data can be merged into the existing document.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * set.\n     * @param {T} data The object to serialize as the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge - If true, set() merges the values\n     * specified in its data argument. Fields omitted from this set() call remain\n     * untouched.\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided, set()\n     * only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched.\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. Throws an error if the write fails.\n     *\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * bulkWriter\n     *  .set(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n    set(documentRef, data, options) {\n        this.verifyNotClosed();\n        const bulkCommitBatch = this.getEligibleBatch();\n        const resultPromise = bulkCommitBatch.set(documentRef, data, options);\n        this.sendReadyBatches();\n        return resultPromise;\n    }\n    /**\n     * Update fields of the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document doesn't yet\n     * exist, the update fails and the entire batch will be rejected.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values. Nested fields can be\n     * updated by providing dot-separated field path strings or by providing\n     * FieldPath objects.\n     *\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * updated.\n     * @param {UpdateData|string|FieldPath} dataOrField An object containing the\n     * fields and values with which to update the document or the path of the\n     * first field to update.\n     * @param {...(Precondition|*|string|FieldPath)} preconditionOrValues - An\n     * alternating list of field paths and values to update or a Precondition to\n     * restrict this update\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. Throws an error if the write fails.\n     *\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * bulkWriter\n     *  .update(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n    update(documentRef, dataOrField, ...preconditionOrValues) {\n        this.verifyNotClosed();\n        const bulkCommitBatch = this.getEligibleBatch();\n        const resultPromise = bulkCommitBatch.update(documentRef, dataOrField, ...preconditionOrValues);\n        this.sendReadyBatches();\n        return resultPromise;\n    }\n    /**\n     * Commits all writes that have been enqueued up to this point in parallel.\n     *\n     * Returns a Promise that resolves when all currently queued operations have\n     * been committed. The Promise will never be rejected since the results for\n     * each individual operation are conveyed via their individual Promises.\n     *\n     * The Promise resolves immediately if there are no pending writes. Otherwise,\n     * the Promise waits for all previously issued writes, but it does not wait\n     * for writes that were added after the method is called. If you want to wait\n     * for additional writes, call `flush()` again.\n     *\n     * @return {Promise<void>} A promise that resolves when all enqueued writes\n     * up to this point have been committed.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter.create(documentRef, {foo: 'bar'});\n     * bulkWriter.update(documentRef2, {foo: 'bar'});\n     * bulkWriter.delete(documentRef3);\n     * await flush().then(() => {\n     *   console.log('Executed all writes');\n     * });\n     */\n    async flush() {\n        this.verifyNotClosed();\n        const trackedBatches = this.batchQueue;\n        const writePromises = trackedBatches.map(batch => batch.awaitBulkCommit());\n        this.sendReadyBatches();\n        await Promise.all(writePromises);\n    }\n    /**\n     * Commits all enqueued writes and marks the BulkWriter instance as closed.\n     *\n     * After calling `close()`, calling any method wil throw an error.\n     *\n     * Returns a Promise that resolves when there are no more pending writes. The\n     * Promise will never be rejected. Calling this method will send all requests.\n     * The promise resolves immediately if there are no pending writes.\n     *\n     * @return {Promise<void>} A promise that resolves when all enqueued writes\n     * up to this point have been committed.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter.create(documentRef, {foo: 'bar'});\n     * bulkWriter.update(documentRef2, {foo: 'bar'});\n     * bulkWriter.delete(documentRef3);\n     * await close().then(() => {\n     *   console.log('Executed all writes');\n     * });\n     */\n    close() {\n        this.verifyNotClosed();\n        this.firestore._decrementBulkWritersCount();\n        const flushPromise = this.flush();\n        this.closed = true;\n        return flushPromise;\n    }\n    verifyNotClosed() {\n        if (this.closed) {\n            throw new Error('BulkWriter has already been closed.');\n        }\n    }\n    /**\n     * Return the first eligible batch that can hold a write to the provided\n     * reference, or creates one if no eligible batches are found.\n     *\n     * @private\n     */\n    getEligibleBatch() {\n        if (this.batchQueue.length > 0) {\n            const lastBatch = this.batchQueue[this.batchQueue.length - 1];\n            if (lastBatch.state === BatchState.OPEN) {\n                return lastBatch;\n            }\n        }\n        return this.createNewBatch();\n    }\n    /**\n     * Creates a new batch and adds it to the BatchQueue. If there is already a\n     * batch enqueued, sends the batch after a new one is created.\n     *\n     * @private\n     */\n    createNewBatch() {\n        const newBatch = new BulkCommitBatch(this.firestore, this.firestore.batch(), this.maxBatchSize);\n        if (this.batchQueue.length > 0) {\n            this.batchQueue[this.batchQueue.length - 1].markReadyToSend();\n            this.sendReadyBatches();\n        }\n        this.batchQueue.push(newBatch);\n        return newBatch;\n    }\n    /**\n     * Attempts to send batches starting from the front of the BatchQueue until a\n     * batch cannot be sent.\n     *\n     * After a batch is complete, try sending batches again.\n     *\n     * @private\n     */\n    sendReadyBatches() {\n        const unsentBatches = this.batchQueue.filter(batch => batch.state === BatchState.READY_TO_SEND);\n        let index = 0;\n        while (index < unsentBatches.length &&\n            unsentBatches[index].state === BatchState.READY_TO_SEND) {\n            const batch = unsentBatches[index];\n            // Send the batch if it is under the rate limit, or schedule another\n            // attempt after the appropriate timeout.\n            const delayMs = this.rateLimiter.getNextRequestDelayMs(batch.opCount);\n            assert(delayMs !== -1, 'Batch size should be under capacity');\n            if (delayMs === 0) {\n                this.sendBatch(batch);\n            }\n            else {\n                backoff_1.delayExecution(() => this.sendReadyBatches(), delayMs);\n                break;\n            }\n            index++;\n        }\n    }\n    /**\n     * Sends the provided batch and processes the results. After the batch is\n     * committed, sends the next group of ready batches.\n     *\n     * @private\n     */\n    sendBatch(batch) {\n        const success = this.rateLimiter.tryMakeRequest(batch.opCount);\n        assert(success, 'Batch should be under rate limit to be sent.');\n        batch.bulkCommit().then(() => {\n            // Remove the batch from the BatchQueue after it has been processed.\n            const batchIndex = this.batchQueue.indexOf(batch);\n            assert(batchIndex !== -1, 'The batch should be in the BatchQueue');\n            this.batchQueue.splice(batchIndex, 1);\n            this.sendReadyBatches();\n        });\n    }\n    /**\n     * Sets the maximum number of allowed operations in a batch.\n     *\n     * @private\n     */\n    // Visible for testing.\n    _setMaxBatchSize(size) {\n        this.maxBatchSize = size;\n    }\n    /**\n     * Returns the rate limiter for testing.\n     *\n     * @private\n     */\n    // Visible for testing.\n    _getRateLimiter() {\n        return this.rateLimiter;\n    }\n}\nexports.BulkWriter = BulkWriter;\n/**\n * Validates the use of 'value' as BulkWriterOptions.\n *\n * @private\n * @param value The BulkWriterOptions object to validate.\n * @throws if the input is not a valid BulkWriterOptions object.\n */\nfunction validateBulkWriterOptions(value) {\n    if (validate_1.validateOptional(value, { optional: true })) {\n        return;\n    }\n    const argName = 'options';\n    if (!util_1.isObject(value)) {\n        throw new Error(`${validate_1.invalidArgumentMessage(argName, 'bulkWriter() options argument')} Input is not an object.`);\n    }\n    const options = value;\n    if (options.throttling === undefined ||\n        typeof options.throttling === 'boolean') {\n        return;\n    }\n    if (options.throttling.initialOpsPerSecond !== undefined) {\n        validate_1.validateInteger('initialOpsPerSecond', options.throttling.initialOpsPerSecond, {\n            minValue: 1,\n        });\n    }\n    if (options.throttling.maxOpsPerSecond !== undefined) {\n        validate_1.validateInteger('maxOpsPerSecond', options.throttling.maxOpsPerSecond, {\n            minValue: 1,\n        });\n        if (options.throttling.initialOpsPerSecond !== undefined &&\n            options.throttling.initialOpsPerSecond >\n                options.throttling.maxOpsPerSecond) {\n            throw new Error(`${validate_1.invalidArgumentMessage(argName, 'bulkWriter() options argument')} \"maxOpsPerSecond\" cannot be less than \"initialOpsPerSecond\".`);\n        }\n    }\n}\n//# sourceMappingURL=bulk-writer.js.map"]},"metadata":{},"sourceType":"script"}