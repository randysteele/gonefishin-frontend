{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _toConsumableArray = require(\"/Users/randysteele/gone-fishin/gone-fishin-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/Users/randysteele/gone-fishin/gone-fishin-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/randysteele/gone-fishin/gone-fishin-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/randysteele/gone-fishin/gone-fishin-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/randysteele/gone-fishin/gone-fishin-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar document_1 = require(\"./document\");\n\nvar logger_1 = require(\"./logger\");\n\nvar path_1 = require(\"./path\");\n\nvar reference_1 = require(\"./reference\");\n\nvar serializer_1 = require(\"./serializer\");\n\nvar timestamp_1 = require(\"./timestamp\");\n\nvar util_1 = require(\"./util\");\n\nvar validate_1 = require(\"./validate\");\n\nvar google_gax_1 = require(\"google-gax\");\n/**\n * A WriteResult wraps the write time set by the Firestore servers on sets(),\n * updates(), and creates().\n *\n * @class\n */\n\n\nvar WriteResult = /*#__PURE__*/function () {\n  /**\n   * @hideconstructor\n   *\n   * @param _writeTime The time of the corresponding document write.\n   */\n  function WriteResult(_writeTime) {\n    _classCallCheck(this, WriteResult);\n\n    this._writeTime = _writeTime;\n  }\n  /**\n   * The write time as set by the Firestore servers.\n   *\n   * @type {Timestamp}\n   * @name WriteResult#writeTime\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.set({foo: 'bar'}).then(writeResult => {\n   *   console.log(`Document written at: ${writeResult.writeTime.toDate()}`);\n   * });\n   */\n\n\n  _createClass(WriteResult, [{\n    key: \"isEqual\",\n\n    /**\n     * Returns true if this `WriteResult` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return true if this `WriteResult` is equal to the provided value.\n     */\n    value: function isEqual(other) {\n      return this === other || other instanceof WriteResult && this._writeTime.isEqual(other._writeTime);\n    }\n  }, {\n    key: \"writeTime\",\n    get: function get() {\n      return this._writeTime;\n    }\n  }]);\n\n  return WriteResult;\n}();\n\nexports.WriteResult = WriteResult;\n/**\n * A BatchWriteResult wraps the write time and status returned by Firestore\n * when making BatchWriteRequests.\n *\n * @private\n */\n\nvar BatchWriteResult = function BatchWriteResult(key, writeTime, status) {\n  _classCallCheck(this, BatchWriteResult);\n\n  this.key = key;\n  this.writeTime = writeTime;\n  this.status = status;\n};\n\nexports.BatchWriteResult = BatchWriteResult;\n/**\n * A Firestore WriteBatch that can be used to atomically commit multiple write\n * operations at once.\n *\n * @class\n */\n\nvar WriteBatch = /*#__PURE__*/function () {\n  function WriteBatch(firestore, retryBatch, indexesToRetry) {\n    _classCallCheck(this, WriteBatch);\n\n    /**\n     * An array of document paths and the corresponding write operations that are\n     * executed as part of the commit. The resulting `api.IWrite` will be sent to\n     * the backend.\n     *\n     * @private\n     */\n    this._ops = [];\n    this._committed = false;\n    this._firestore = firestore;\n    this._serializer = new serializer_1.Serializer(firestore);\n    this._allowUndefined = !!firestore._settings.ignoreUndefinedProperties;\n\n    if (retryBatch) {\n      // Creates a new WriteBatch containing only the indexes from the provided\n      // indexes to retry.\n      this._ops = retryBatch._ops.filter(function (op, index) {\n        return indexesToRetry.has(index);\n      });\n    }\n  }\n  /**\n   * Checks if this write batch has any pending operations.\n   *\n   * @private\n   */\n\n\n  _createClass(WriteBatch, [{\n    key: \"verifyNotCommitted\",\n\n    /**\n     * Throws an error if this batch has already been committed.\n     *\n     * @private\n     */\n    value: function verifyNotCommitted() {\n      if (this._committed) {\n        throw new Error('Cannot modify a WriteBatch that has been committed.');\n      }\n    }\n    /**\n     * Create a document with the provided object values. This will fail the batch\n     * if a document exists at its location.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * created.\n     * @param {T} data The object to serialize as the document.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * writeBatch.create(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n\n  }, {\n    key: \"create\",\n    value: function create(documentRef, data) {\n      var _this = this;\n\n      var ref = reference_1.validateDocumentReference('documentRef', documentRef);\n\n      var firestoreData = ref._converter.toFirestore(data);\n\n      validateDocumentData('data', firestoreData,\n      /* allowDeletes= */\n      false, this._allowUndefined);\n      this.verifyNotCommitted();\n      var transform = document_1.DocumentTransform.fromObject(ref, firestoreData);\n      transform.validate();\n      var precondition = new document_1.Precondition({\n        exists: false\n      });\n\n      var op = function op() {\n        var document = document_1.DocumentSnapshot.fromObject(ref, firestoreData);\n        var write = document.toWriteProto();\n\n        if (!transform.isEmpty) {\n          write.updateTransforms = transform.toProto(_this._serializer);\n        }\n\n        write.currentDocument = precondition.toProto();\n        return write;\n      };\n\n      this._ops.push({\n        docPath: documentRef.path,\n        op: op\n      });\n\n      return this;\n    }\n    /**\n     * Deletes a document from the database.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * deleted.\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the batch if the\n     * document doesn't exist or was last updated at a different time.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.delete(documentRef);\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(documentRef, precondition) {\n      var ref = reference_1.validateDocumentReference('documentRef', documentRef);\n      validateDeletePrecondition('precondition', precondition, {\n        optional: true\n      });\n      this.verifyNotCommitted();\n      var conditions = new document_1.Precondition(precondition);\n\n      var op = function op() {\n        var write = {\n          delete: ref.formattedName\n        };\n\n        if (!conditions.isEmpty) {\n          write.currentDocument = conditions.toProto();\n        }\n\n        return write;\n      };\n\n      this._ops.push({\n        docPath: documentRef.path,\n        op: op\n      });\n\n      return this;\n    }\n    /**\n     * Write to the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document does not\n     * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions},\n     * the provided data can be merged into the existing document.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * set.\n     * @param {T|Partial<T>} data The object to serialize as the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge - If true, set() merges the values\n     * specified in its data argument. Fields omitted from this set() call\n     * remain untouched.\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,\n     * set() only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.set(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(documentRef, data, options) {\n      var _this2 = this;\n\n      validateSetOptions('options', options, {\n        optional: true\n      });\n      var mergeLeaves = options && options.merge === true;\n      var mergePaths = options && options.mergeFields;\n      var ref = reference_1.validateDocumentReference('documentRef', documentRef);\n      var firestoreData;\n\n      if (mergeLeaves || mergePaths) {\n        // Cast to any in order to satisfy the union type constraint on\n        // toFirestore().\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        firestoreData = ref._converter.toFirestore(data, options);\n      } else {\n        firestoreData = ref._converter.toFirestore(data);\n      }\n\n      validateDocumentData('data', firestoreData,\n      /* allowDeletes= */\n      !!(mergePaths || mergeLeaves), this._allowUndefined);\n      this.verifyNotCommitted();\n      var documentMask;\n\n      if (mergePaths) {\n        documentMask = document_1.DocumentMask.fromFieldMask(options.mergeFields);\n        firestoreData = documentMask.applyTo(firestoreData);\n      }\n\n      var transform = document_1.DocumentTransform.fromObject(documentRef, firestoreData);\n      transform.validate();\n\n      var op = function op() {\n        var document = document_1.DocumentSnapshot.fromObject(documentRef, firestoreData);\n\n        if (mergePaths) {\n          documentMask.removeFields(transform.fields);\n        } else if (mergeLeaves) {\n          documentMask = document_1.DocumentMask.fromObject(firestoreData);\n        }\n\n        var write = document.toWriteProto();\n\n        if (!transform.isEmpty) {\n          write.updateTransforms = transform.toProto(_this2._serializer);\n        }\n\n        if (mergePaths || mergeLeaves) {\n          write.updateMask = documentMask.toProto();\n        }\n\n        return write;\n      };\n\n      this._ops.push({\n        docPath: documentRef.path,\n        op: op\n      });\n\n      return this;\n    }\n    /**\n     * Update fields of the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document\n     * doesn't yet exist, the update fails and the entire batch will be rejected.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values. Nested fields can be\n     * updated by providing dot-separated field path strings or by providing\n     * FieldPath objects.\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * updated.\n     * @param {UpdateData|string|FieldPath} dataOrField An object\n     * containing the fields and values with which to update the document\n     * or the path of the first field to update.\n     * @param {\n     * ...(Precondition|*|string|FieldPath)} preconditionOrValues -\n     * An alternating list of field paths and values to update or a Precondition\n     * to restrict this update.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.update(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(documentRef, dataOrField) {\n      var _this3 = this;\n\n      for (var _len = arguments.length, preconditionOrValues = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        preconditionOrValues[_key - 2] = arguments[_key];\n      }\n\n      // eslint-disable-next-line prefer-rest-params\n      validate_1.validateMinNumberOfArguments('WriteBatch.update', arguments, 2);\n      reference_1.validateDocumentReference('documentRef', documentRef);\n      this.verifyNotCommitted();\n      var updateMap = new Map();\n      var precondition = new document_1.Precondition({\n        exists: true\n      });\n      var argumentError = 'Update() requires either a single JavaScript ' + 'object or an alternating list of field/value pairs that can be ' + 'followed by an optional precondition.';\n      var usesVarargs = typeof dataOrField === 'string' || dataOrField instanceof path_1.FieldPath;\n\n      if (usesVarargs) {\n        var argumentOffset = 1; // Respect 'documentRef' in the error message\n\n        var fieldOrValues = [dataOrField].concat(preconditionOrValues);\n\n        try {\n          for (var i = 0; i < fieldOrValues.length; i += 2) {\n            if (i === fieldOrValues.length - 1) {\n              var maybePrecondition = fieldOrValues[i];\n              validateUpdatePrecondition(i + argumentOffset, maybePrecondition);\n              precondition = new document_1.Precondition(maybePrecondition);\n            } else {\n              var maybeFieldPath = fieldOrValues[i];\n              path_1.validateFieldPath(i + argumentOffset, maybeFieldPath); // Unlike the `validateMinNumberOfArguments` invocation above, this\n              // validation can be triggered both from `WriteBatch.update()` and\n              // `DocumentReference.update()`. Hence, we don't use the fully\n              // qualified API name in the error message.\n\n              validate_1.validateMinNumberOfArguments('update', fieldOrValues, i + 1);\n              var fieldPath = path_1.FieldPath.fromArgument(maybeFieldPath);\n              validateFieldValue(i + argumentOffset, fieldOrValues[i + 1], this._allowUndefined, fieldPath);\n              updateMap.set(fieldPath, fieldOrValues[i + 1]);\n            }\n          }\n        } catch (err) {\n          logger_1.logger('WriteBatch.update', null, 'Varargs validation failed:', err); // We catch the validation error here and re-throw to provide a better\n          // error message.\n\n          throw new Error(\"\".concat(argumentError, \" \").concat(err.message));\n        }\n      } else {\n        try {\n          validateUpdateMap('dataOrField', dataOrField, this._allowUndefined); // eslint-disable-next-line prefer-rest-params\n\n          validate_1.validateMaxNumberOfArguments('update', arguments, 3);\n          var data = dataOrField;\n          Object.keys(data).forEach(function (key) {\n            path_1.validateFieldPath(key, key);\n            updateMap.set(path_1.FieldPath.fromArgument(key), data[key]);\n          });\n\n          if (preconditionOrValues.length > 0) {\n            validateUpdatePrecondition('preconditionOrValues', preconditionOrValues[0]);\n            precondition = new document_1.Precondition(preconditionOrValues[0]);\n          }\n        } catch (err) {\n          logger_1.logger('WriteBatch.update', null, 'Non-varargs validation failed:', err); // We catch the validation error here and prefix the error with a custom\n          // message to describe the usage of update() better.\n\n          throw new Error(\"\".concat(argumentError, \" \").concat(err.message));\n        }\n      }\n\n      validateNoConflictingFields('dataOrField', updateMap);\n      var transform = document_1.DocumentTransform.fromUpdateMap(documentRef, updateMap);\n      transform.validate();\n      var documentMask = document_1.DocumentMask.fromUpdateMap(updateMap);\n\n      var op = function op() {\n        var document = document_1.DocumentSnapshot.fromUpdateMap(documentRef, updateMap);\n        var write = document.toWriteProto();\n        write.updateMask = documentMask.toProto();\n\n        if (!transform.isEmpty) {\n          write.updateTransforms = transform.toProto(_this3._serializer);\n        }\n\n        write.currentDocument = precondition.toProto();\n        return write;\n      };\n\n      this._ops.push({\n        docPath: documentRef.path,\n        op: op\n      });\n\n      return this;\n    }\n    /**\n     * Atomically commits all pending operations to the database and verifies all\n     * preconditions. Fails the entire write if any precondition is not met.\n     *\n     * @returns {Promise.<Array.<WriteResult>>} A Promise that resolves\n     * when this batch completes.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.set(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      // Capture the error stack to preserve stack tracing across async calls.\n      var stack = Error().stack;\n      return this._commit().catch(function (err) {\n        throw util_1.wrapError(err, stack);\n      });\n    }\n    /**\n     * Commits all pending operations to the database and verifies all\n     * preconditions.\n     *\n     * The writes in the batch are not applied atomically and can be applied out\n     * of order.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"bulkCommit\",\n    value: function () {\n      var _bulkCommit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this4 = this;\n\n        var tag, database, request, retryCodes, response;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this._committed = true;\n                tag = util_1.requestTag();\n                _context.next = 4;\n                return this._firestore.initializeIfNeeded(tag);\n\n              case 4:\n                database = this._firestore.formattedName;\n                request = {\n                  database: database,\n                  writes: this._ops.map(function (op) {\n                    return op.op();\n                  })\n                };\n                retryCodes = util_1.getRetryCodes('batchWrite');\n                _context.next = 9;\n                return this._firestore.request('batchWrite', request, tag, retryCodes);\n\n              case 9:\n                response = _context.sent;\n                return _context.abrupt(\"return\", response.writeResults.map(function (result, i) {\n                  var status = response.status[i];\n                  var error = new google_gax_1.GoogleError(status.message || undefined);\n                  error.code = status.code; // Since delete operations currently do not have write times, use a\n                  // sentinel Timestamp value.\n                  // TODO(b/158502664): Use actual delete timestamp.\n\n                  var DELETE_TIMESTAMP_SENTINEL = timestamp_1.Timestamp.fromMillis(0);\n                  var updateTime = error.code === google_gax_1.Status.OK ? timestamp_1.Timestamp.fromProto(result.updateTime || DELETE_TIMESTAMP_SENTINEL) : null;\n                  return new BatchWriteResult(_this4._ops[i].docPath, updateTime, error);\n                }));\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function bulkCommit() {\n        return _bulkCommit.apply(this, arguments);\n      }\n\n      return bulkCommit;\n    }()\n    /**\n     * Commit method that takes an optional transaction ID.\n     *\n     * @private\n     * @param commitOptions Options to use for this commit.\n     * @param commitOptions.transactionId The transaction ID of this commit.\n     * @param commitOptions.requestTag A unique client-assigned identifier for\n     * this request.\n     * @returns  A Promise that resolves when this batch completes.\n     */\n\n  }, {\n    key: \"_commit\",\n    value: function () {\n      var _commit2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(commitOptions) {\n        var tag, database, explicitTransaction, request, retryCodes, response;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // Note: We don't call `verifyNotCommitted()` to allow for retries.\n                this._committed = true;\n                tag = commitOptions && commitOptions.requestTag || util_1.requestTag();\n                _context2.next = 4;\n                return this._firestore.initializeIfNeeded(tag);\n\n              case 4:\n                database = this._firestore.formattedName;\n                explicitTransaction = commitOptions && commitOptions.transactionId;\n                request = {\n                  database: database,\n                  writes: this._ops.map(function (op) {\n                    return op.op();\n                  })\n                };\n\n                if (commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.transactionId) {\n                  request.transaction = commitOptions.transactionId;\n                }\n\n                logger_1.logger('WriteBatch.commit', tag, 'Sending %d writes', request.writes.length);\n\n                if (explicitTransaction) {\n                  request.transaction = explicitTransaction;\n                } else {\n                  // Commits outside of transaction should also be retried when they fail\n                  // with status code ABORTED.\n                  retryCodes = [google_gax_1.Status.ABORTED].concat(_toConsumableArray(util_1.getRetryCodes('commit')));\n                }\n\n                _context2.next = 12;\n                return this._firestore.request('commit', request, tag, retryCodes);\n\n              case 12:\n                response = _context2.sent;\n                return _context2.abrupt(\"return\", (response.writeResults || []).map(function (writeResult) {\n                  return new WriteResult(timestamp_1.Timestamp.fromProto(writeResult.updateTime || response.commitTime));\n                }));\n\n              case 14:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _commit(_x) {\n        return _commit2.apply(this, arguments);\n      }\n\n      return _commit;\n    }()\n    /**\n     * Resets the WriteBatch and dequeues all pending operations.\n     * @private\n     */\n\n  }, {\n    key: \"_reset\",\n    value: function _reset() {\n      this._ops.splice(0);\n\n      this._committed = false;\n    }\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return this._ops.length === 0;\n    }\n  }]);\n\n  return WriteBatch;\n}();\n\nexports.WriteBatch = WriteBatch;\n/**\n * Validates the use of 'value' as a Precondition and enforces that 'exists'\n * and 'lastUpdateTime' use valid types.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate\n * @param allowExists Whether to allow the 'exists' preconditions.\n */\n\nfunction validatePrecondition(arg, value, allowExists) {\n  if (typeof value !== 'object' || value === null) {\n    throw new Error('Input is not an object.');\n  }\n\n  var precondition = value;\n  var conditions = 0;\n\n  if (precondition.exists !== undefined) {\n    ++conditions;\n\n    if (!allowExists) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'precondition'), \" \\\"exists\\\" is not an allowed precondition.\"));\n    }\n\n    if (typeof precondition.exists !== 'boolean') {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'precondition'), \" \\\"exists\\\" is not a boolean.'\"));\n    }\n  }\n\n  if (precondition.lastUpdateTime !== undefined) {\n    ++conditions;\n\n    if (!(precondition.lastUpdateTime instanceof timestamp_1.Timestamp)) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'precondition'), \" \\\"lastUpdateTime\\\" is not a Firestore Timestamp.\"));\n    }\n  }\n\n  if (conditions > 1) {\n    throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'precondition'), \" Input specifies more than one precondition.\"));\n  }\n}\n/**\n * Validates the use of 'value' as an update Precondition.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n */\n\n\nfunction validateUpdatePrecondition(arg, value, options) {\n  if (!validate_1.validateOptional(value, options)) {\n    validatePrecondition(arg, value,\n    /* allowExists= */\n    false);\n  }\n}\n/**\n * Validates the use of 'value' as a delete Precondition.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n */\n\n\nfunction validateDeletePrecondition(arg, value, options) {\n  if (!validate_1.validateOptional(value, options)) {\n    validatePrecondition(arg, value,\n    /* allowExists= */\n    true);\n  }\n}\n/**\n * Validates the use of 'value' as SetOptions and enforces that 'merge' is a\n * boolean.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n * @throws if the input is not a valid SetOptions object.\n */\n\n\nfunction validateSetOptions(arg, value, options) {\n  if (!validate_1.validateOptional(value, options)) {\n    if (!util_1.isObject(value)) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'set() options argument'), \" Input is not an object.\"));\n    }\n\n    var setOptions = value;\n\n    if ('merge' in setOptions && typeof setOptions.merge !== 'boolean') {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'set() options argument'), \" \\\"merge\\\" is not a boolean.\"));\n    }\n\n    if ('mergeFields' in setOptions) {\n      if (!Array.isArray(setOptions.mergeFields)) {\n        throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'set() options argument'), \" \\\"mergeFields\\\" is not an array.\"));\n      }\n\n      for (var i = 0; i < setOptions.mergeFields.length; ++i) {\n        try {\n          path_1.validateFieldPath(i, setOptions.mergeFields[i]);\n        } catch (err) {\n          throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'set() options argument'), \" \\\"mergeFields\\\" is not valid: \").concat(err.message));\n        }\n      }\n    }\n\n    if ('merge' in setOptions && 'mergeFields' in setOptions) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'set() options argument'), \" You cannot specify both \\\"merge\\\" and \\\"mergeFields\\\".\"));\n    }\n  }\n}\n\nexports.validateSetOptions = validateSetOptions;\n/**\n * Validates a JavaScript object for usage as a Firestore document.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param obj JavaScript object to validate.\n * @param allowDeletes Whether to allow FieldValue.delete() sentinels.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n * @throws when the object is invalid.\n */\n\nfunction validateDocumentData(arg, obj, allowDeletes, allowUndefined) {\n  if (!util_1.isPlainObject(obj)) {\n    throw new Error(validate_1.customObjectMessage(arg, obj));\n  }\n\n  serializer_1.validateUserInput(arg, obj, 'Firestore document', {\n    allowDeletes: allowDeletes ? 'all' : 'none',\n    allowTransforms: true,\n    allowUndefined: allowUndefined\n  });\n}\n\nexports.validateDocumentData = validateDocumentData;\n/**\n * Validates that a value can be used as field value during an update.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param val The value to verify.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n * @param path The path to show in the error message.\n */\n\nfunction validateFieldValue(arg, val, allowUndefined, path) {\n  serializer_1.validateUserInput(arg, val, 'Firestore value', {\n    allowDeletes: 'root',\n    allowTransforms: true,\n    allowUndefined: allowUndefined\n  }, path);\n}\n\nexports.validateFieldValue = validateFieldValue;\n/**\n * Validates that the update data does not contain any ambiguous field\n * definitions (such as 'a.b' and 'a').\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param data An update map with field/value pairs.\n */\n\nfunction validateNoConflictingFields(arg, data) {\n  var fields = [];\n  data.forEach(function (value, key) {\n    fields.push(key);\n  });\n  fields.sort(function (left, right) {\n    return left.compareTo(right);\n  });\n\n  for (var i = 1; i < fields.length; ++i) {\n    if (fields[i - 1].isPrefixOf(fields[i])) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'update map'), \" Field \\\"\").concat(fields[i - 1], \"\\\" was specified multiple times.\"));\n    }\n  }\n}\n/**\n * Validates that a JavaScript object is a map of field paths to field values.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param obj JavaScript object to validate.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n * @throws when the object is invalid.\n */\n\n\nfunction validateUpdateMap(arg, obj, allowUndefined) {\n  if (!util_1.isPlainObject(obj)) {\n    throw new Error(validate_1.customObjectMessage(arg, obj));\n  }\n\n  var isEmpty = true;\n\n  if (obj) {\n    for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {\n      var prop = _Object$keys[_i];\n      isEmpty = false;\n      validateFieldValue(arg, obj[prop], allowUndefined, new path_1.FieldPath(prop));\n    }\n  }\n\n  if (isEmpty) {\n    throw new Error('At least one field must be updated.');\n  }\n}","map":{"version":3,"sources":["/Users/randysteele/gone-fishin/gone-fishin-frontend/node_modules/@google-cloud/firestore/build/src/write-batch.js"],"names":["Object","defineProperty","exports","value","document_1","require","logger_1","path_1","reference_1","serializer_1","timestamp_1","util_1","validate_1","google_gax_1","WriteResult","_writeTime","other","isEqual","BatchWriteResult","key","writeTime","status","WriteBatch","firestore","retryBatch","indexesToRetry","_ops","_committed","_firestore","_serializer","Serializer","_allowUndefined","_settings","ignoreUndefinedProperties","filter","op","index","has","Error","documentRef","data","ref","validateDocumentReference","firestoreData","_converter","toFirestore","validateDocumentData","verifyNotCommitted","transform","DocumentTransform","fromObject","validate","precondition","Precondition","exists","document","DocumentSnapshot","write","toWriteProto","isEmpty","updateTransforms","toProto","currentDocument","push","docPath","path","validateDeletePrecondition","optional","conditions","delete","formattedName","options","validateSetOptions","mergeLeaves","merge","mergePaths","mergeFields","documentMask","DocumentMask","fromFieldMask","applyTo","removeFields","fields","updateMask","dataOrField","preconditionOrValues","validateMinNumberOfArguments","arguments","updateMap","Map","argumentError","usesVarargs","FieldPath","argumentOffset","fieldOrValues","i","length","maybePrecondition","validateUpdatePrecondition","maybeFieldPath","validateFieldPath","fieldPath","fromArgument","validateFieldValue","set","err","logger","message","validateUpdateMap","validateMaxNumberOfArguments","keys","forEach","validateNoConflictingFields","fromUpdateMap","stack","_commit","catch","wrapError","tag","requestTag","initializeIfNeeded","database","request","writes","map","retryCodes","getRetryCodes","response","writeResults","result","error","GoogleError","undefined","code","DELETE_TIMESTAMP_SENTINEL","Timestamp","fromMillis","updateTime","Status","OK","fromProto","commitOptions","explicitTransaction","transactionId","transaction","ABORTED","writeResult","commitTime","splice","validatePrecondition","arg","allowExists","invalidArgumentMessage","lastUpdateTime","validateOptional","isObject","setOptions","Array","isArray","obj","allowDeletes","allowUndefined","isPlainObject","customObjectMessage","validateUserInput","allowTransforms","val","sort","left","right","compareTo","isPrefixOf","prop"],"mappings":"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","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst document_1 = require(\"./document\");\nconst logger_1 = require(\"./logger\");\nconst path_1 = require(\"./path\");\nconst reference_1 = require(\"./reference\");\nconst serializer_1 = require(\"./serializer\");\nconst timestamp_1 = require(\"./timestamp\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nconst google_gax_1 = require(\"google-gax\");\n/**\n * A WriteResult wraps the write time set by the Firestore servers on sets(),\n * updates(), and creates().\n *\n * @class\n */\nclass WriteResult {\n    /**\n     * @hideconstructor\n     *\n     * @param _writeTime The time of the corresponding document write.\n     */\n    constructor(_writeTime) {\n        this._writeTime = _writeTime;\n    }\n    /**\n     * The write time as set by the Firestore servers.\n     *\n     * @type {Timestamp}\n     * @name WriteResult#writeTime\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({foo: 'bar'}).then(writeResult => {\n     *   console.log(`Document written at: ${writeResult.writeTime.toDate()}`);\n     * });\n     */\n    get writeTime() {\n        return this._writeTime;\n    }\n    /**\n     * Returns true if this `WriteResult` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return true if this `WriteResult` is equal to the provided value.\n     */\n    isEqual(other) {\n        return (this === other ||\n            (other instanceof WriteResult &&\n                this._writeTime.isEqual(other._writeTime)));\n    }\n}\nexports.WriteResult = WriteResult;\n/**\n * A BatchWriteResult wraps the write time and status returned by Firestore\n * when making BatchWriteRequests.\n *\n * @private\n */\nclass BatchWriteResult {\n    constructor(key, writeTime, status) {\n        this.key = key;\n        this.writeTime = writeTime;\n        this.status = status;\n    }\n}\nexports.BatchWriteResult = BatchWriteResult;\n/**\n * A Firestore WriteBatch that can be used to atomically commit multiple write\n * operations at once.\n *\n * @class\n */\nclass WriteBatch {\n    constructor(firestore, retryBatch, indexesToRetry) {\n        /**\n         * An array of document paths and the corresponding write operations that are\n         * executed as part of the commit. The resulting `api.IWrite` will be sent to\n         * the backend.\n         *\n         * @private\n         */\n        this._ops = [];\n        this._committed = false;\n        this._firestore = firestore;\n        this._serializer = new serializer_1.Serializer(firestore);\n        this._allowUndefined = !!firestore._settings.ignoreUndefinedProperties;\n        if (retryBatch) {\n            // Creates a new WriteBatch containing only the indexes from the provided\n            // indexes to retry.\n            this._ops = retryBatch._ops.filter((op, index) => indexesToRetry.has(index));\n        }\n    }\n    /**\n     * Checks if this write batch has any pending operations.\n     *\n     * @private\n     */\n    get isEmpty() {\n        return this._ops.length === 0;\n    }\n    /**\n     * Throws an error if this batch has already been committed.\n     *\n     * @private\n     */\n    verifyNotCommitted() {\n        if (this._committed) {\n            throw new Error('Cannot modify a WriteBatch that has been committed.');\n        }\n    }\n    /**\n     * Create a document with the provided object values. This will fail the batch\n     * if a document exists at its location.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * created.\n     * @param {T} data The object to serialize as the document.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * writeBatch.create(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n    create(documentRef, data) {\n        const ref = reference_1.validateDocumentReference('documentRef', documentRef);\n        const firestoreData = ref._converter.toFirestore(data);\n        validateDocumentData('data', firestoreData, \n        /* allowDeletes= */ false, this._allowUndefined);\n        this.verifyNotCommitted();\n        const transform = document_1.DocumentTransform.fromObject(ref, firestoreData);\n        transform.validate();\n        const precondition = new document_1.Precondition({ exists: false });\n        const op = () => {\n            const document = document_1.DocumentSnapshot.fromObject(ref, firestoreData);\n            const write = document.toWriteProto();\n            if (!transform.isEmpty) {\n                write.updateTransforms = transform.toProto(this._serializer);\n            }\n            write.currentDocument = precondition.toProto();\n            return write;\n        };\n        this._ops.push({ docPath: documentRef.path, op });\n        return this;\n    }\n    /**\n     * Deletes a document from the database.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * deleted.\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the batch if the\n     * document doesn't exist or was last updated at a different time.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.delete(documentRef);\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n    delete(documentRef, precondition) {\n        const ref = reference_1.validateDocumentReference('documentRef', documentRef);\n        validateDeletePrecondition('precondition', precondition, { optional: true });\n        this.verifyNotCommitted();\n        const conditions = new document_1.Precondition(precondition);\n        const op = () => {\n            const write = { delete: ref.formattedName };\n            if (!conditions.isEmpty) {\n                write.currentDocument = conditions.toProto();\n            }\n            return write;\n        };\n        this._ops.push({ docPath: documentRef.path, op });\n        return this;\n    }\n    /**\n     * Write to the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document does not\n     * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions},\n     * the provided data can be merged into the existing document.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * set.\n     * @param {T|Partial<T>} data The object to serialize as the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge - If true, set() merges the values\n     * specified in its data argument. Fields omitted from this set() call\n     * remain untouched.\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,\n     * set() only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.set(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n    set(documentRef, data, options) {\n        validateSetOptions('options', options, { optional: true });\n        const mergeLeaves = options && options.merge === true;\n        const mergePaths = options && options.mergeFields;\n        const ref = reference_1.validateDocumentReference('documentRef', documentRef);\n        let firestoreData;\n        if (mergeLeaves || mergePaths) {\n            // Cast to any in order to satisfy the union type constraint on\n            // toFirestore().\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            firestoreData = ref._converter.toFirestore(data, options);\n        }\n        else {\n            firestoreData = ref._converter.toFirestore(data);\n        }\n        validateDocumentData('data', firestoreData, \n        /* allowDeletes= */ !!(mergePaths || mergeLeaves), this._allowUndefined);\n        this.verifyNotCommitted();\n        let documentMask;\n        if (mergePaths) {\n            documentMask = document_1.DocumentMask.fromFieldMask(options.mergeFields);\n            firestoreData = documentMask.applyTo(firestoreData);\n        }\n        const transform = document_1.DocumentTransform.fromObject(documentRef, firestoreData);\n        transform.validate();\n        const op = () => {\n            const document = document_1.DocumentSnapshot.fromObject(documentRef, firestoreData);\n            if (mergePaths) {\n                documentMask.removeFields(transform.fields);\n            }\n            else if (mergeLeaves) {\n                documentMask = document_1.DocumentMask.fromObject(firestoreData);\n            }\n            const write = document.toWriteProto();\n            if (!transform.isEmpty) {\n                write.updateTransforms = transform.toProto(this._serializer);\n            }\n            if (mergePaths || mergeLeaves) {\n                write.updateMask = documentMask.toProto();\n            }\n            return write;\n        };\n        this._ops.push({ docPath: documentRef.path, op });\n        return this;\n    }\n    /**\n     * Update fields of the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document\n     * doesn't yet exist, the update fails and the entire batch will be rejected.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values. Nested fields can be\n     * updated by providing dot-separated field path strings or by providing\n     * FieldPath objects.\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * updated.\n     * @param {UpdateData|string|FieldPath} dataOrField An object\n     * containing the fields and values with which to update the document\n     * or the path of the first field to update.\n     * @param {\n     * ...(Precondition|*|string|FieldPath)} preconditionOrValues -\n     * An alternating list of field paths and values to update or a Precondition\n     * to restrict this update.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.update(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n    update(documentRef, dataOrField, ...preconditionOrValues) {\n        // eslint-disable-next-line prefer-rest-params\n        validate_1.validateMinNumberOfArguments('WriteBatch.update', arguments, 2);\n        reference_1.validateDocumentReference('documentRef', documentRef);\n        this.verifyNotCommitted();\n        const updateMap = new Map();\n        let precondition = new document_1.Precondition({ exists: true });\n        const argumentError = 'Update() requires either a single JavaScript ' +\n            'object or an alternating list of field/value pairs that can be ' +\n            'followed by an optional precondition.';\n        const usesVarargs = typeof dataOrField === 'string' || dataOrField instanceof path_1.FieldPath;\n        if (usesVarargs) {\n            const argumentOffset = 1; // Respect 'documentRef' in the error message\n            const fieldOrValues = [dataOrField, ...preconditionOrValues];\n            try {\n                for (let i = 0; i < fieldOrValues.length; i += 2) {\n                    if (i === fieldOrValues.length - 1) {\n                        const maybePrecondition = fieldOrValues[i];\n                        validateUpdatePrecondition(i + argumentOffset, maybePrecondition);\n                        precondition = new document_1.Precondition(maybePrecondition);\n                    }\n                    else {\n                        const maybeFieldPath = fieldOrValues[i];\n                        path_1.validateFieldPath(i + argumentOffset, maybeFieldPath);\n                        // Unlike the `validateMinNumberOfArguments` invocation above, this\n                        // validation can be triggered both from `WriteBatch.update()` and\n                        // `DocumentReference.update()`. Hence, we don't use the fully\n                        // qualified API name in the error message.\n                        validate_1.validateMinNumberOfArguments('update', fieldOrValues, i + 1);\n                        const fieldPath = path_1.FieldPath.fromArgument(maybeFieldPath);\n                        validateFieldValue(i + argumentOffset, fieldOrValues[i + 1], this._allowUndefined, fieldPath);\n                        updateMap.set(fieldPath, fieldOrValues[i + 1]);\n                    }\n                }\n            }\n            catch (err) {\n                logger_1.logger('WriteBatch.update', null, 'Varargs validation failed:', err);\n                // We catch the validation error here and re-throw to provide a better\n                // error message.\n                throw new Error(`${argumentError} ${err.message}`);\n            }\n        }\n        else {\n            try {\n                validateUpdateMap('dataOrField', dataOrField, this._allowUndefined);\n                // eslint-disable-next-line prefer-rest-params\n                validate_1.validateMaxNumberOfArguments('update', arguments, 3);\n                const data = dataOrField;\n                Object.keys(data).forEach(key => {\n                    path_1.validateFieldPath(key, key);\n                    updateMap.set(path_1.FieldPath.fromArgument(key), data[key]);\n                });\n                if (preconditionOrValues.length > 0) {\n                    validateUpdatePrecondition('preconditionOrValues', preconditionOrValues[0]);\n                    precondition = new document_1.Precondition(preconditionOrValues[0]);\n                }\n            }\n            catch (err) {\n                logger_1.logger('WriteBatch.update', null, 'Non-varargs validation failed:', err);\n                // We catch the validation error here and prefix the error with a custom\n                // message to describe the usage of update() better.\n                throw new Error(`${argumentError} ${err.message}`);\n            }\n        }\n        validateNoConflictingFields('dataOrField', updateMap);\n        const transform = document_1.DocumentTransform.fromUpdateMap(documentRef, updateMap);\n        transform.validate();\n        const documentMask = document_1.DocumentMask.fromUpdateMap(updateMap);\n        const op = () => {\n            const document = document_1.DocumentSnapshot.fromUpdateMap(documentRef, updateMap);\n            const write = document.toWriteProto();\n            write.updateMask = documentMask.toProto();\n            if (!transform.isEmpty) {\n                write.updateTransforms = transform.toProto(this._serializer);\n            }\n            write.currentDocument = precondition.toProto();\n            return write;\n        };\n        this._ops.push({ docPath: documentRef.path, op });\n        return this;\n    }\n    /**\n     * Atomically commits all pending operations to the database and verifies all\n     * preconditions. Fails the entire write if any precondition is not met.\n     *\n     * @returns {Promise.<Array.<WriteResult>>} A Promise that resolves\n     * when this batch completes.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.set(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n    commit() {\n        // Capture the error stack to preserve stack tracing across async calls.\n        const stack = Error().stack;\n        return this._commit().catch(err => {\n            throw util_1.wrapError(err, stack);\n        });\n    }\n    /**\n     * Commits all pending operations to the database and verifies all\n     * preconditions.\n     *\n     * The writes in the batch are not applied atomically and can be applied out\n     * of order.\n     *\n     * @private\n     */\n    async bulkCommit() {\n        this._committed = true;\n        const tag = util_1.requestTag();\n        await this._firestore.initializeIfNeeded(tag);\n        const database = this._firestore.formattedName;\n        const request = {\n            database,\n            writes: this._ops.map(op => op.op()),\n        };\n        const retryCodes = util_1.getRetryCodes('batchWrite');\n        const response = await this._firestore.request('batchWrite', request, tag, retryCodes);\n        return response.writeResults.map((result, i) => {\n            const status = response.status[i];\n            const error = new google_gax_1.GoogleError(status.message || undefined);\n            error.code = status.code;\n            // Since delete operations currently do not have write times, use a\n            // sentinel Timestamp value.\n            // TODO(b/158502664): Use actual delete timestamp.\n            const DELETE_TIMESTAMP_SENTINEL = timestamp_1.Timestamp.fromMillis(0);\n            const updateTime = error.code === google_gax_1.Status.OK\n                ? timestamp_1.Timestamp.fromProto(result.updateTime || DELETE_TIMESTAMP_SENTINEL)\n                : null;\n            return new BatchWriteResult(this._ops[i].docPath, updateTime, error);\n        });\n    }\n    /**\n     * Commit method that takes an optional transaction ID.\n     *\n     * @private\n     * @param commitOptions Options to use for this commit.\n     * @param commitOptions.transactionId The transaction ID of this commit.\n     * @param commitOptions.requestTag A unique client-assigned identifier for\n     * this request.\n     * @returns  A Promise that resolves when this batch completes.\n     */\n    async _commit(commitOptions) {\n        // Note: We don't call `verifyNotCommitted()` to allow for retries.\n        this._committed = true;\n        const tag = (commitOptions && commitOptions.requestTag) || util_1.requestTag();\n        await this._firestore.initializeIfNeeded(tag);\n        const database = this._firestore.formattedName;\n        const explicitTransaction = commitOptions && commitOptions.transactionId;\n        const request = {\n            database,\n            writes: this._ops.map(op => op.op()),\n        };\n        if (commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.transactionId) {\n            request.transaction = commitOptions.transactionId;\n        }\n        logger_1.logger('WriteBatch.commit', tag, 'Sending %d writes', request.writes.length);\n        let retryCodes;\n        if (explicitTransaction) {\n            request.transaction = explicitTransaction;\n        }\n        else {\n            // Commits outside of transaction should also be retried when they fail\n            // with status code ABORTED.\n            retryCodes = [google_gax_1.Status.ABORTED, ...util_1.getRetryCodes('commit')];\n        }\n        const response = await this._firestore.request('commit', request, tag, retryCodes);\n        return (response.writeResults || []).map(writeResult => new WriteResult(timestamp_1.Timestamp.fromProto(writeResult.updateTime || response.commitTime)));\n    }\n    /**\n     * Resets the WriteBatch and dequeues all pending operations.\n     * @private\n     */\n    _reset() {\n        this._ops.splice(0);\n        this._committed = false;\n    }\n}\nexports.WriteBatch = WriteBatch;\n/**\n * Validates the use of 'value' as a Precondition and enforces that 'exists'\n * and 'lastUpdateTime' use valid types.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate\n * @param allowExists Whether to allow the 'exists' preconditions.\n */\nfunction validatePrecondition(arg, value, allowExists) {\n    if (typeof value !== 'object' || value === null) {\n        throw new Error('Input is not an object.');\n    }\n    const precondition = value;\n    let conditions = 0;\n    if (precondition.exists !== undefined) {\n        ++conditions;\n        if (!allowExists) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'precondition')} \"exists\" is not an allowed precondition.`);\n        }\n        if (typeof precondition.exists !== 'boolean') {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'precondition')} \"exists\" is not a boolean.'`);\n        }\n    }\n    if (precondition.lastUpdateTime !== undefined) {\n        ++conditions;\n        if (!(precondition.lastUpdateTime instanceof timestamp_1.Timestamp)) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'precondition')} \"lastUpdateTime\" is not a Firestore Timestamp.`);\n        }\n    }\n    if (conditions > 1) {\n        throw new Error(`${validate_1.invalidArgumentMessage(arg, 'precondition')} Input specifies more than one precondition.`);\n    }\n}\n/**\n * Validates the use of 'value' as an update Precondition.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n */\nfunction validateUpdatePrecondition(arg, value, options) {\n    if (!validate_1.validateOptional(value, options)) {\n        validatePrecondition(arg, value, /* allowExists= */ false);\n    }\n}\n/**\n * Validates the use of 'value' as a delete Precondition.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n */\nfunction validateDeletePrecondition(arg, value, options) {\n    if (!validate_1.validateOptional(value, options)) {\n        validatePrecondition(arg, value, /* allowExists= */ true);\n    }\n}\n/**\n * Validates the use of 'value' as SetOptions and enforces that 'merge' is a\n * boolean.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n * @throws if the input is not a valid SetOptions object.\n */\nfunction validateSetOptions(arg, value, options) {\n    if (!validate_1.validateOptional(value, options)) {\n        if (!util_1.isObject(value)) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} Input is not an object.`);\n        }\n        const setOptions = value;\n        if ('merge' in setOptions && typeof setOptions.merge !== 'boolean') {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} \"merge\" is not a boolean.`);\n        }\n        if ('mergeFields' in setOptions) {\n            if (!Array.isArray(setOptions.mergeFields)) {\n                throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} \"mergeFields\" is not an array.`);\n            }\n            for (let i = 0; i < setOptions.mergeFields.length; ++i) {\n                try {\n                    path_1.validateFieldPath(i, setOptions.mergeFields[i]);\n                }\n                catch (err) {\n                    throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} \"mergeFields\" is not valid: ${err.message}`);\n                }\n            }\n        }\n        if ('merge' in setOptions && 'mergeFields' in setOptions) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} You cannot specify both \"merge\" and \"mergeFields\".`);\n        }\n    }\n}\nexports.validateSetOptions = validateSetOptions;\n/**\n * Validates a JavaScript object for usage as a Firestore document.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param obj JavaScript object to validate.\n * @param allowDeletes Whether to allow FieldValue.delete() sentinels.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n * @throws when the object is invalid.\n */\nfunction validateDocumentData(arg, obj, allowDeletes, allowUndefined) {\n    if (!util_1.isPlainObject(obj)) {\n        throw new Error(validate_1.customObjectMessage(arg, obj));\n    }\n    serializer_1.validateUserInput(arg, obj, 'Firestore document', {\n        allowDeletes: allowDeletes ? 'all' : 'none',\n        allowTransforms: true,\n        allowUndefined,\n    });\n}\nexports.validateDocumentData = validateDocumentData;\n/**\n * Validates that a value can be used as field value during an update.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param val The value to verify.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n * @param path The path to show in the error message.\n */\nfunction validateFieldValue(arg, val, allowUndefined, path) {\n    serializer_1.validateUserInput(arg, val, 'Firestore value', { allowDeletes: 'root', allowTransforms: true, allowUndefined }, path);\n}\nexports.validateFieldValue = validateFieldValue;\n/**\n * Validates that the update data does not contain any ambiguous field\n * definitions (such as 'a.b' and 'a').\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param data An update map with field/value pairs.\n */\nfunction validateNoConflictingFields(arg, data) {\n    const fields = [];\n    data.forEach((value, key) => {\n        fields.push(key);\n    });\n    fields.sort((left, right) => left.compareTo(right));\n    for (let i = 1; i < fields.length; ++i) {\n        if (fields[i - 1].isPrefixOf(fields[i])) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'update map')} Field \"${fields[i - 1]}\" was specified multiple times.`);\n        }\n    }\n}\n/**\n * Validates that a JavaScript object is a map of field paths to field values.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param obj JavaScript object to validate.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n * @throws when the object is invalid.\n */\nfunction validateUpdateMap(arg, obj, allowUndefined) {\n    if (!util_1.isPlainObject(obj)) {\n        throw new Error(validate_1.customObjectMessage(arg, obj));\n    }\n    let isEmpty = true;\n    if (obj) {\n        for (const prop of Object.keys(obj)) {\n            isEmpty = false;\n            validateFieldValue(arg, obj[prop], allowUndefined, new path_1.FieldPath(prop));\n        }\n    }\n    if (isEmpty) {\n        throw new Error('At least one field must be updated.');\n    }\n}\n//# sourceMappingURL=write-batch.js.map"]},"metadata":{},"sourceType":"script"}