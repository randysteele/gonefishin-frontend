{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _get = require(\"/Users/randysteele/gone-fishin/gone-fishin-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/randysteele/gone-fishin/gone-fishin-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/randysteele/gone-fishin/gone-fishin-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/randysteele/gone-fishin/gone-fishin-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _slicedToArray = require(\"/Users/randysteele/gone-fishin/gone-fishin-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/randysteele/gone-fishin/gone-fishin-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/randysteele/gone-fishin/gone-fishin-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/randysteele/gone-fishin/gone-fishin-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar deepEqual = require(\"fast-deep-equal\");\n\nvar assert = require(\"assert\");\n\nvar field_value_1 = require(\"./field-value\");\n\nvar path_1 = require(\"./path\");\n\nvar reference_1 = require(\"./reference\");\n\nvar types_1 = require(\"./types\");\n\nvar util_1 = require(\"./util\");\n/**\n * Returns a builder for DocumentSnapshot and QueryDocumentSnapshot instances.\n * Invoke `.build()' to assemble the final snapshot.\n *\n * @private\n */\n\n\nvar DocumentSnapshotBuilder = /*#__PURE__*/function () {\n  // We include the DocumentReference in the constructor in order to allow the\n  // DocumentSnapshotBuilder to be typed with <T> when it is constructed.\n  function DocumentSnapshotBuilder(ref) {\n    _classCallCheck(this, DocumentSnapshotBuilder);\n\n    this.ref = ref;\n  }\n  /**\n   * Builds the DocumentSnapshot.\n   *\n   * @private\n   * @returns Returns either a QueryDocumentSnapshot (if `fieldsProto` was\n   * provided) or a DocumentSnapshot.\n   */\n\n\n  _createClass(DocumentSnapshotBuilder, [{\n    key: \"build\",\n    value: function build() {\n      assert(this.fieldsProto !== undefined === (this.createTime !== undefined), 'Create time should be set iff document exists.');\n      assert(this.fieldsProto !== undefined === (this.updateTime !== undefined), 'Update time should be set iff document exists.');\n      return this.fieldsProto ? new QueryDocumentSnapshot(this.ref, this.fieldsProto, this.readTime, this.createTime, this.updateTime) : new DocumentSnapshot(this.ref, undefined, this.readTime);\n    }\n  }]);\n\n  return DocumentSnapshotBuilder;\n}();\n\nexports.DocumentSnapshotBuilder = DocumentSnapshotBuilder;\n/**\n * A DocumentSnapshot is an immutable representation for a document in a\n * Firestore database. The data can be extracted with\n * [data()]{@link DocumentSnapshot#data} or\n * [get(fieldPath)]{@link DocumentSnapshot#get} to get a\n * specific field.\n *\n * <p>For a DocumentSnapshot that points to a non-existing document, any data\n * access will return 'undefined'. You can use the\n * [exists]{@link DocumentSnapshot#exists} property to explicitly verify a\n * document's existence.\n *\n * @class\n */\n\nvar DocumentSnapshot = /*#__PURE__*/function () {\n  /**\n   * @hideconstructor\n   *\n   * @param ref The reference to the document.\n   * @param _fieldsProto The fields of the Firestore `Document` Protobuf backing\n   * this document (or undefined if the document does not exist).\n   * @param readTime The time when this snapshot was read  (or undefined if\n   * the document exists only locally).\n   * @param createTime The time when the document was created (or undefined if\n   * the document does not exist).\n   * @param updateTime The time when the document was last updated (or undefined\n   * if the document does not exist).\n   */\n  function DocumentSnapshot(ref, _fieldsProto, readTime, createTime, updateTime) {\n    _classCallCheck(this, DocumentSnapshot);\n\n    this._fieldsProto = _fieldsProto;\n    this._ref = ref;\n    this._serializer = ref.firestore._serializer;\n    this._readTime = readTime;\n    this._createTime = createTime;\n    this._updateTime = updateTime;\n  }\n  /**\n   * Creates a DocumentSnapshot from an object.\n   *\n   * @private\n   * @param ref The reference to the document.\n   * @param obj The object to store in the DocumentSnapshot.\n   * @return The created DocumentSnapshot.\n   */\n\n\n  _createClass(DocumentSnapshot, [{\n    key: \"data\",\n\n    /**\n     * Retrieves all fields in the document as an object. Returns 'undefined' if\n     * the document doesn't exist.\n     *\n     * @returns {T|undefined} An object containing all fields in the document or\n     * 'undefined' if the document doesn't exist.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   let data = documentSnapshot.data();\n     *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n     * });\n     */\n    value: function data() {\n      var fields = this._fieldsProto;\n\n      if (fields === undefined) {\n        return undefined;\n      } // We only want to use the converter and create a new QueryDocumentSnapshot\n      // if a converter has been provided.\n\n\n      if (this.ref._converter !== types_1.defaultConverter()) {\n        var untypedReference = new reference_1.DocumentReference(this.ref.firestore, this.ref._path);\n        return this.ref._converter.fromFirestore(new QueryDocumentSnapshot(untypedReference, this._fieldsProto, this.readTime, this.createTime, this.updateTime));\n      } else {\n        var obj = {};\n\n        for (var _i = 0, _Object$keys = Object.keys(fields); _i < _Object$keys.length; _i++) {\n          var prop = _Object$keys[_i];\n          obj[prop] = this._serializer.decodeValue(fields[prop]);\n        }\n\n        return obj;\n      }\n    }\n    /**\n     * Retrieves the field specified by `field`.\n     *\n     * @param {string|FieldPath} field The field path\n     * (e.g. 'foo' or 'foo.bar') to a specific field.\n     * @returns {*} The data at the specified field location or undefined if no\n     * such field exists.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({ a: { b: 'c' }}).then(() => {\n     *   return documentRef.get();\n     * }).then(documentSnapshot => {\n     *   let field = documentSnapshot.get('a.b');\n     *   console.log(`Retrieved field value: ${field}`);\n     * });\n     */\n    // We deliberately use `any` in the external API to not impose type-checking\n    // on end users.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  }, {\n    key: \"get\",\n    value: function get(field) {\n      path_1.validateFieldPath('field', field);\n      var protoField = this.protoField(field);\n\n      if (protoField === undefined) {\n        return undefined;\n      }\n\n      return this._serializer.decodeValue(protoField);\n    }\n    /**\n     * Retrieves the field specified by 'fieldPath' in its Protobuf JS\n     * representation.\n     *\n     * @private\n     * @param field The path (e.g. 'foo' or 'foo.bar') to a specific field.\n     * @returns The Protobuf-encoded data at the specified field location or\n     * undefined if no such field exists.\n     */\n\n  }, {\n    key: \"protoField\",\n    value: function protoField(field) {\n      var fields = this._fieldsProto;\n\n      if (fields === undefined) {\n        return undefined;\n      }\n\n      var components = path_1.FieldPath.fromArgument(field).toArray();\n\n      while (components.length > 1) {\n        fields = fields[components.shift()];\n\n        if (!fields || !fields.mapValue) {\n          return undefined;\n        }\n\n        fields = fields.mapValue.fields;\n      }\n\n      return fields[components[0]];\n    }\n    /**\n     * Convert a document snapshot to the Firestore 'Write' proto.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"toWriteProto\",\n    value: function toWriteProto() {\n      return {\n        update: {\n          name: this._ref.formattedName,\n          fields: this._fieldsProto\n        }\n      };\n    }\n    /**\n     * Convert a document snapshot to the Firestore 'Document' proto.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"toDocumentProto\",\n    value: function toDocumentProto() {\n      return {\n        name: this._ref.formattedName,\n        createTime: this.createTime,\n        updateTime: this.updateTime,\n        fields: this._fieldsProto\n      };\n    }\n    /**\n     * Returns true if the document's data and path in this `DocumentSnapshot` is\n     * equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `DocumentSnapshot` is equal to the provided\n     * value.\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(other) {\n      // Since the read time is different on every document read, we explicitly\n      // ignore all document metadata in this comparison.\n      return this === other || other instanceof DocumentSnapshot && this._ref.isEqual(other._ref) && deepEqual(this._fieldsProto, other._fieldsProto);\n    }\n  }, {\n    key: \"exists\",\n\n    /**\n     * True if the document exists.\n     *\n     * @type {boolean}\n     * @name DocumentSnapshot#exists\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then((documentSnapshot) => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(`Data: ${JSON.stringify(documentSnapshot.data())}`);\n     *   }\n     * });\n     */\n    get: function get() {\n      return this._fieldsProto !== undefined;\n    }\n    /**\n     * A [DocumentReference]{@link DocumentReference} for the document\n     * stored in this snapshot.\n     *\n     * @type {DocumentReference}\n     * @name DocumentSnapshot#ref\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then((documentSnapshot) => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(`Found document at '${documentSnapshot.ref.path}'`);\n     *   }\n     * });\n     */\n\n  }, {\n    key: \"ref\",\n    get: function get() {\n      return this._ref;\n    }\n    /**\n     * The ID of the document for which this DocumentSnapshot contains data.\n     *\n     * @type {string}\n     * @name DocumentSnapshot#id\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then((documentSnapshot) => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(`Document found with name '${documentSnapshot.id}'`);\n     *   }\n     * });\n     */\n\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._ref.id;\n    }\n    /**\n     * The time the document was created. Undefined for documents that don't\n     * exist.\n     *\n     * @type {Timestamp|undefined}\n     * @name DocumentSnapshot#createTime\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     let createTime = documentSnapshot.createTime;\n     *     console.log(`Document created at '${createTime.toDate()}'`);\n     *   }\n     * });\n     */\n\n  }, {\n    key: \"createTime\",\n    get: function get() {\n      return this._createTime;\n    }\n    /**\n     * The time the document was last updated (at the time the snapshot was\n     * generated). Undefined for documents that don't exist.\n     *\n     * @type {Timestamp|undefined}\n     * @name DocumentSnapshot#updateTime\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     let updateTime = documentSnapshot.updateTime;\n     *     console.log(`Document updated at '${updateTime.toDate()}'`);\n     *   }\n     * });\n     */\n\n  }, {\n    key: \"updateTime\",\n    get: function get() {\n      return this._updateTime;\n    }\n    /**\n     * The time this snapshot was read.\n     *\n     * @type {Timestamp}\n     * @name DocumentSnapshot#readTime\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   let readTime = documentSnapshot.readTime;\n     *   console.log(`Document read at '${readTime.toDate()}'`);\n     * });\n     */\n\n  }, {\n    key: \"readTime\",\n    get: function get() {\n      if (this._readTime === undefined) {\n        throw new Error(\"Called 'readTime' on a local document\");\n      }\n\n      return this._readTime;\n    }\n  }], [{\n    key: \"fromObject\",\n    value: function fromObject(ref, obj) {\n      var serializer = ref.firestore._serializer;\n      return new DocumentSnapshot(ref, serializer.encodeFields(obj));\n    }\n    /**\n     * Creates a DocumentSnapshot from an UpdateMap.\n     *\n     * This methods expands the top-level field paths in a JavaScript map and\n     * turns { foo.bar : foobar } into { foo { bar : foobar }}\n     *\n     * @private\n     * @param ref The reference to the document.\n     * @param data The field/value map to expand.\n     * @return The created DocumentSnapshot.\n     */\n\n  }, {\n    key: \"fromUpdateMap\",\n    value: function fromUpdateMap(ref, data) {\n      var serializer = ref.firestore._serializer;\n      /**\n       * Merges 'value' at the field path specified by the path array into\n       * 'target'.\n       */\n\n      function merge(target, value, path, pos) {\n        var key = path[pos];\n        var isLast = pos === path.length - 1;\n\n        if (target[key] === undefined) {\n          if (isLast) {\n            if (value instanceof field_value_1.FieldTransform) {\n              // If there is already data at this path, we need to retain it.\n              // Otherwise, we don't include it in the DocumentSnapshot.\n              return !util_1.isEmpty(target) ? target : null;\n            } // The merge is done.\n\n\n            var leafNode = serializer.encodeValue(value);\n\n            if (leafNode) {\n              target[key] = leafNode;\n            }\n\n            return target;\n          } else {\n            // We need to expand the target object.\n            var childNode = {\n              mapValue: {\n                fields: {}\n              }\n            };\n            var nestedValue = merge(childNode.mapValue.fields, value, path, pos + 1);\n\n            if (nestedValue) {\n              childNode.mapValue.fields = nestedValue;\n              target[key] = childNode;\n              return target;\n            } else {\n              return !util_1.isEmpty(target) ? target : null;\n            }\n          }\n        } else {\n          assert(!isLast, \"Can't merge current value into a nested object\");\n          target[key].mapValue.fields = merge(target[key].mapValue.fields, value, path, pos + 1);\n          return target;\n        }\n      }\n\n      var res = {};\n\n      var _iterator = _createForOfIteratorHelper(data),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              key = _step$value[0],\n              value = _step$value[1];\n\n          var path = key.toArray();\n          merge(res, value, path, 0);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return new DocumentSnapshot(ref, res);\n    }\n  }]);\n\n  return DocumentSnapshot;\n}();\n\nexports.DocumentSnapshot = DocumentSnapshot;\n/**\n * A QueryDocumentSnapshot contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with [data()]{@link QueryDocumentSnapshot#data}\n * or [get()]{@link DocumentSnapshot#get} to get a specific field.\n *\n * A QueryDocumentSnapshot offers the same API surface as a\n * {@link DocumentSnapshot}. Since query results contain only existing\n * documents, the [exists]{@link DocumentSnapshot#exists} property will\n * always be true and [data()]{@link QueryDocumentSnapshot#data} will never\n * return 'undefined'.\n *\n * @class\n * @extends DocumentSnapshot\n */\n\nvar QueryDocumentSnapshot = /*#__PURE__*/function (_DocumentSnapshot) {\n  _inherits(QueryDocumentSnapshot, _DocumentSnapshot);\n\n  var _super = _createSuper(QueryDocumentSnapshot);\n\n  function QueryDocumentSnapshot() {\n    _classCallCheck(this, QueryDocumentSnapshot);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(QueryDocumentSnapshot, [{\n    key: \"data\",\n\n    /**\n     * Retrieves all fields in the document as an object.\n     *\n     * @override\n     *\n     * @returns {T} An object containing all fields in the document.\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.get().forEach(documentSnapshot => {\n     *   let data = documentSnapshot.data();\n     *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n     * });\n     */\n    value: function data() {\n      var data = _get(_getPrototypeOf(QueryDocumentSnapshot.prototype), \"data\", this).call(this);\n\n      if (!data) {\n        throw new Error('The data in a QueryDocumentSnapshot should always exist.');\n      }\n\n      return data;\n    }\n  }, {\n    key: \"createTime\",\n\n    /**\n     * The time the document was created.\n     *\n     * @type {Timestamp}\n     * @name QueryDocumentSnapshot#createTime\n     * @readonly\n     * @override\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.get().forEach(snapshot => {\n     *   console.log(`Document created at '${snapshot.createTime.toDate()}'`);\n     * });\n     */\n    get: function get() {\n      return _get(_getPrototypeOf(QueryDocumentSnapshot.prototype), \"createTime\", this);\n    }\n    /**\n     * The time the document was last updated (at the time the snapshot was\n     * generated).\n     *\n     * @type {Timestamp}\n     * @name QueryDocumentSnapshot#updateTime\n     * @readonly\n     * @override\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.get().forEach(snapshot => {\n     *   console.log(`Document updated at '${snapshot.updateTime.toDate()}'`);\n     * });\n     */\n\n  }, {\n    key: \"updateTime\",\n    get: function get() {\n      return _get(_getPrototypeOf(QueryDocumentSnapshot.prototype), \"updateTime\", this);\n    }\n  }]);\n\n  return QueryDocumentSnapshot;\n}(DocumentSnapshot);\n\nexports.QueryDocumentSnapshot = QueryDocumentSnapshot;\n/**\n * A Firestore Document Mask contains the field paths affected by an update.\n *\n * @class\n * @private\n */\n\nvar DocumentMask = /*#__PURE__*/function () {\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param fieldPaths The field paths in this mask.\n   */\n  function DocumentMask(fieldPaths) {\n    _classCallCheck(this, DocumentMask);\n\n    this._sortedPaths = fieldPaths;\n\n    this._sortedPaths.sort(function (a, b) {\n      return a.compareTo(b);\n    });\n  }\n  /**\n   * Creates a document mask with the field paths of a document.\n   *\n   * @private\n   * @param data A map with fields to modify. Only the keys are used to extract\n   * the document mask.\n   */\n\n\n  _createClass(DocumentMask, [{\n    key: \"removeFields\",\n\n    /**\n     * Removes the field path specified in 'fieldPaths' from this document mask.\n     *\n     * @private\n     * @param fieldPaths An array of FieldPaths.\n     */\n    value: function removeFields(fieldPaths) {\n      DocumentMask.removeFromSortedArray(this._sortedPaths, fieldPaths);\n    }\n    /**\n     * Returns whether this document mask contains 'fieldPath'.\n     *\n     * @private\n     * @param fieldPath The field path to test.\n     * @return Whether this document mask contains 'fieldPath'.\n     */\n\n  }, {\n    key: \"contains\",\n    value: function contains(fieldPath) {\n      var _iterator2 = _createForOfIteratorHelper(this._sortedPaths),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var sortedPath = _step2.value;\n          var cmp = sortedPath.compareTo(fieldPath);\n\n          if (cmp === 0) {\n            return true;\n          } else if (cmp > 0) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return false;\n    }\n    /**\n     * Removes all properties from 'data' that are not contained in this document\n     * mask.\n     *\n     * @private\n     * @param data An object to filter.\n     * @return A shallow copy of the object filtered by this document mask.\n     */\n\n  }, {\n    key: \"applyTo\",\n    value: function applyTo(data) {\n      var _this = this;\n\n      /*!\n       * Applies this DocumentMask to 'data' and computes the list of field paths\n       * that were specified in the mask but are not present in 'data'.\n       */\n      var applyDocumentMask = function applyDocumentMask(data) {\n        var remainingPaths = _this._sortedPaths.slice(0);\n\n        var processObject = function processObject(currentData, currentPath) {\n          var result = null;\n          Object.keys(currentData).forEach(function (key) {\n            var childPath = currentPath ? currentPath.append(key) : new path_1.FieldPath(key);\n\n            if (_this.contains(childPath)) {\n              DocumentMask.removeFromSortedArray(remainingPaths, [childPath]);\n              result = result || {};\n              result[key] = currentData[key];\n            } else if (util_1.isObject(currentData[key])) {\n              var childObject = processObject(currentData[key], childPath);\n\n              if (childObject) {\n                result = result || {};\n                result[key] = childObject;\n              }\n            }\n          });\n          return result;\n        }; // processObject() returns 'null' if the DocumentMask is empty.\n\n\n        var filteredData = processObject(data) || {};\n        return {\n          filteredData: filteredData,\n          remainingPaths: remainingPaths\n        };\n      };\n\n      var result = applyDocumentMask(data);\n\n      if (result.remainingPaths.length !== 0) {\n        throw new Error(\"Input data is missing for field \\\"\".concat(result.remainingPaths[0], \"\\\".\"));\n      }\n\n      return result.filteredData;\n    }\n    /**\n     * Converts a document mask to the Firestore 'DocumentMask' Proto.\n     *\n     * @private\n     * @returns A Firestore 'DocumentMask' Proto.\n     */\n\n  }, {\n    key: \"toProto\",\n    value: function toProto() {\n      if (this.isEmpty) {\n        return {};\n      }\n\n      var encodedPaths = [];\n\n      var _iterator3 = _createForOfIteratorHelper(this._sortedPaths),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var fieldPath = _step3.value;\n          encodedPaths.push(fieldPath.formattedName);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return {\n        fieldPaths: encodedPaths\n      };\n    }\n  }, {\n    key: \"isEmpty\",\n\n    /**\n     * Returns true if this document mask contains no fields.\n     *\n     * @private\n     * @return {boolean} Whether this document mask is empty.\n     */\n    get: function get() {\n      return this._sortedPaths.length === 0;\n    }\n    /**\n     * Removes the specified values from a sorted field path array.\n     *\n     * @private\n     * @param input A sorted array of FieldPaths.\n     * @param values An array of FieldPaths to remove.\n     */\n\n  }], [{\n    key: \"fromUpdateMap\",\n    value: function fromUpdateMap(data) {\n      var fieldPaths = [];\n      data.forEach(function (value, key) {\n        if (!(value instanceof field_value_1.FieldTransform) || value.includeInDocumentMask) {\n          fieldPaths.push(path_1.FieldPath.fromArgument(key));\n        }\n      });\n      return new DocumentMask(fieldPaths);\n    }\n    /**\n     * Creates a document mask from an array of field paths.\n     *\n     * @private\n     * @param fieldMask A list of field paths.\n     */\n\n  }, {\n    key: \"fromFieldMask\",\n    value: function fromFieldMask(fieldMask) {\n      var fieldPaths = [];\n\n      var _iterator4 = _createForOfIteratorHelper(fieldMask),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var fieldPath = _step4.value;\n          fieldPaths.push(path_1.FieldPath.fromArgument(fieldPath));\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return new DocumentMask(fieldPaths);\n    }\n    /**\n     * Creates a document mask with the field names of a document.\n     *\n     * @private\n     * @param data An object with fields to modify. Only the keys are used to\n     * extract the document mask.\n     */\n\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(data) {\n      var fieldPaths = [];\n\n      function extractFieldPaths(currentData, currentPath) {\n        var isEmpty = true;\n\n        for (var _i2 = 0, _Object$keys2 = Object.keys(currentData); _i2 < _Object$keys2.length; _i2++) {\n          var key = _Object$keys2[_i2];\n          isEmpty = false; // We don't split on dots since fromObject is called with\n          // DocumentData.\n\n          var childSegment = new path_1.FieldPath(key);\n          var childPath = currentPath ? currentPath.append(childSegment) : childSegment;\n          var value = currentData[key];\n\n          if (value instanceof field_value_1.FieldTransform) {\n            if (value.includeInDocumentMask) {\n              fieldPaths.push(childPath);\n            }\n          } else if (util_1.isPlainObject(value)) {\n            extractFieldPaths(value, childPath);\n          } else {\n            fieldPaths.push(childPath);\n          }\n        } // Add a field path for an explicitly updated empty map.\n\n\n        if (currentPath && isEmpty) {\n          fieldPaths.push(currentPath);\n        }\n      }\n\n      extractFieldPaths(data);\n      return new DocumentMask(fieldPaths);\n    }\n  }, {\n    key: \"removeFromSortedArray\",\n    value: function removeFromSortedArray(input, values) {\n      for (var i = 0; i < input.length;) {\n        var removed = false;\n\n        var _iterator5 = _createForOfIteratorHelper(values),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var fieldPath = _step5.value;\n\n            if (input[i].isEqual(fieldPath)) {\n              input.splice(i, 1);\n              removed = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n\n        if (!removed) {\n          ++i;\n        }\n      }\n    }\n  }]);\n\n  return DocumentMask;\n}();\n\nexports.DocumentMask = DocumentMask;\n/**\n * A Firestore Document Transform.\n *\n * A DocumentTransform contains pending server-side transforms and their\n * corresponding field paths.\n *\n * @private\n * @class\n */\n\nvar DocumentTransform = /*#__PURE__*/function () {\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param ref The DocumentReference for this transform.\n   * @param transforms A Map of FieldPaths to FieldTransforms.\n   */\n  function DocumentTransform(ref, transforms) {\n    _classCallCheck(this, DocumentTransform);\n\n    this.ref = ref;\n    this.transforms = transforms;\n  }\n  /**\n   * Generates a DocumentTransform from a JavaScript object.\n   *\n   * @private\n   * @param ref The `DocumentReference` to use for the DocumentTransform.\n   * @param obj The object to extract the transformations from.\n   * @returns The Document Transform.\n   */\n\n\n  _createClass(DocumentTransform, [{\n    key: \"validate\",\n\n    /**\n     * Validates the user provided field values in this document transform.\n     * @private\n     */\n    value: function validate() {\n      var allowUndefined = !!this.ref.firestore._settings.ignoreUndefinedProperties;\n      this.transforms.forEach(function (transform) {\n        return transform.validate(allowUndefined);\n      });\n    }\n    /**\n     * Converts a document transform to the Firestore 'FieldTransform' Proto.\n     *\n     * @private\n     * @param serializer The Firestore serializer\n     * @returns A list of Firestore 'FieldTransform' Protos\n     */\n\n  }, {\n    key: \"toProto\",\n    value: function toProto(serializer) {\n      return Array.from(this.transforms, function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            path = _ref2[0],\n            transform = _ref2[1];\n\n        return transform.toProto(serializer, path);\n      });\n    }\n  }, {\n    key: \"isEmpty\",\n\n    /**\n     * Whether this DocumentTransform contains any actionable transformations.\n     *\n     * @private\n     */\n    get: function get() {\n      return this.transforms.size === 0;\n    }\n    /**\n     * Returns the array of fields in this DocumentTransform.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"fields\",\n    get: function get() {\n      return Array.from(this.transforms.keys());\n    }\n  }], [{\n    key: \"fromObject\",\n    value: function fromObject(ref, obj) {\n      var updateMap = new Map();\n\n      for (var _i3 = 0, _Object$keys3 = Object.keys(obj); _i3 < _Object$keys3.length; _i3++) {\n        var prop = _Object$keys3[_i3];\n        updateMap.set(new path_1.FieldPath(prop), obj[prop]);\n      }\n\n      return DocumentTransform.fromUpdateMap(ref, updateMap);\n    }\n    /**\n     * Generates a DocumentTransform from an Update Map.\n     *\n     * @private\n     * @param ref The `DocumentReference` to use for the DocumentTransform.\n     * @param data The update data to extract the transformations from.\n     * @returns The Document Transform.\n     */\n\n  }, {\n    key: \"fromUpdateMap\",\n    value: function fromUpdateMap(ref, data) {\n      var transforms = new Map();\n\n      function encode_(val, path, allowTransforms) {\n        if (val instanceof field_value_1.FieldTransform && val.includeInDocumentTransform) {\n          if (allowTransforms) {\n            transforms.set(path, val);\n          } else {\n            throw new Error(\"\".concat(val.methodName, \"() is not supported inside of array values.\"));\n          }\n        } else if (Array.isArray(val)) {\n          for (var i = 0; i < val.length; ++i) {\n            // We need to verify that no array value contains a document transform\n            encode_(val[i], path.append(String(i)), false);\n          }\n        } else if (util_1.isPlainObject(val)) {\n          for (var _i4 = 0, _Object$keys4 = Object.keys(val); _i4 < _Object$keys4.length; _i4++) {\n            var prop = _Object$keys4[_i4];\n            encode_(val[prop], path.append(new path_1.FieldPath(prop)), allowTransforms);\n          }\n        }\n      }\n\n      data.forEach(function (value, key) {\n        encode_(value, path_1.FieldPath.fromArgument(key), true);\n      });\n      return new DocumentTransform(ref, transforms);\n    }\n  }]);\n\n  return DocumentTransform;\n}();\n\nexports.DocumentTransform = DocumentTransform;\n/**\n * A Firestore Precondition encapsulates options for database writes.\n *\n * @private\n * @class\n */\n\nvar Precondition = /*#__PURE__*/function () {\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param options.exists - Whether the referenced document should exist in\n   * Firestore,\n   * @param options.lastUpdateTime - The last update time of the referenced\n   * document in Firestore.\n   * @param options\n   */\n  function Precondition(options) {\n    _classCallCheck(this, Precondition);\n\n    if (options !== undefined) {\n      this._exists = options.exists;\n      this._lastUpdateTime = options.lastUpdateTime;\n    }\n  }\n  /**\n   * Generates the Protobuf `Preconditon` object for this precondition.\n   *\n   * @private\n   * @returns The `Preconditon` Protobuf object or 'null' if there are no\n   * preconditions.\n   */\n\n\n  _createClass(Precondition, [{\n    key: \"toProto\",\n    value: function toProto() {\n      if (this.isEmpty) {\n        return null;\n      }\n\n      var proto = {};\n\n      if (this._lastUpdateTime !== undefined) {\n        proto.updateTime = this._lastUpdateTime.toProto().timestampValue;\n      } else {\n        proto.exists = this._exists;\n      }\n\n      return proto;\n    }\n    /**\n     * Whether this DocumentTransform contains any enforcement.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return this._exists === undefined && !this._lastUpdateTime;\n    }\n  }]);\n\n  return Precondition;\n}();\n\nexports.Precondition = Precondition;","map":{"version":3,"sources":["/Users/randysteele/gone-fishin/gone-fishin-frontend/node_modules/@google-cloud/firestore/build/src/document.js"],"names":["Object","defineProperty","exports","value","deepEqual","require","assert","field_value_1","path_1","reference_1","types_1","util_1","DocumentSnapshotBuilder","ref","fieldsProto","undefined","createTime","updateTime","QueryDocumentSnapshot","readTime","DocumentSnapshot","_fieldsProto","_ref","_serializer","firestore","_readTime","_createTime","_updateTime","fields","_converter","defaultConverter","untypedReference","DocumentReference","_path","fromFirestore","obj","keys","prop","decodeValue","field","validateFieldPath","protoField","components","FieldPath","fromArgument","toArray","length","shift","mapValue","update","name","formattedName","other","isEqual","id","Error","serializer","encodeFields","data","merge","target","path","pos","key","isLast","FieldTransform","isEmpty","leafNode","encodeValue","childNode","nestedValue","res","DocumentMask","fieldPaths","_sortedPaths","sort","a","b","compareTo","removeFromSortedArray","fieldPath","sortedPath","cmp","applyDocumentMask","remainingPaths","slice","processObject","currentData","currentPath","result","forEach","childPath","append","contains","isObject","childObject","filteredData","encodedPaths","push","includeInDocumentMask","fieldMask","extractFieldPaths","childSegment","isPlainObject","input","values","i","removed","splice","DocumentTransform","transforms","allowUndefined","_settings","ignoreUndefinedProperties","transform","validate","Array","from","toProto","size","updateMap","Map","set","fromUpdateMap","encode_","val","allowTransforms","includeInDocumentTransform","methodName","isArray","String","Precondition","options","_exists","exists","_lastUpdateTime","lastUpdateTime","proto","timestampValue"],"mappings":"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","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst deepEqual = require(\"fast-deep-equal\");\nconst assert = require(\"assert\");\nconst field_value_1 = require(\"./field-value\");\nconst path_1 = require(\"./path\");\nconst reference_1 = require(\"./reference\");\nconst types_1 = require(\"./types\");\nconst util_1 = require(\"./util\");\n/**\n * Returns a builder for DocumentSnapshot and QueryDocumentSnapshot instances.\n * Invoke `.build()' to assemble the final snapshot.\n *\n * @private\n */\nclass DocumentSnapshotBuilder {\n    // We include the DocumentReference in the constructor in order to allow the\n    // DocumentSnapshotBuilder to be typed with <T> when it is constructed.\n    constructor(ref) {\n        this.ref = ref;\n    }\n    /**\n     * Builds the DocumentSnapshot.\n     *\n     * @private\n     * @returns Returns either a QueryDocumentSnapshot (if `fieldsProto` was\n     * provided) or a DocumentSnapshot.\n     */\n    build() {\n        assert((this.fieldsProto !== undefined) === (this.createTime !== undefined), 'Create time should be set iff document exists.');\n        assert((this.fieldsProto !== undefined) === (this.updateTime !== undefined), 'Update time should be set iff document exists.');\n        return this.fieldsProto\n            ? new QueryDocumentSnapshot(this.ref, this.fieldsProto, this.readTime, this.createTime, this.updateTime)\n            : new DocumentSnapshot(this.ref, undefined, this.readTime);\n    }\n}\nexports.DocumentSnapshotBuilder = DocumentSnapshotBuilder;\n/**\n * A DocumentSnapshot is an immutable representation for a document in a\n * Firestore database. The data can be extracted with\n * [data()]{@link DocumentSnapshot#data} or\n * [get(fieldPath)]{@link DocumentSnapshot#get} to get a\n * specific field.\n *\n * <p>For a DocumentSnapshot that points to a non-existing document, any data\n * access will return 'undefined'. You can use the\n * [exists]{@link DocumentSnapshot#exists} property to explicitly verify a\n * document's existence.\n *\n * @class\n */\nclass DocumentSnapshot {\n    /**\n     * @hideconstructor\n     *\n     * @param ref The reference to the document.\n     * @param _fieldsProto The fields of the Firestore `Document` Protobuf backing\n     * this document (or undefined if the document does not exist).\n     * @param readTime The time when this snapshot was read  (or undefined if\n     * the document exists only locally).\n     * @param createTime The time when the document was created (or undefined if\n     * the document does not exist).\n     * @param updateTime The time when the document was last updated (or undefined\n     * if the document does not exist).\n     */\n    constructor(ref, _fieldsProto, readTime, createTime, updateTime) {\n        this._fieldsProto = _fieldsProto;\n        this._ref = ref;\n        this._serializer = ref.firestore._serializer;\n        this._readTime = readTime;\n        this._createTime = createTime;\n        this._updateTime = updateTime;\n    }\n    /**\n     * Creates a DocumentSnapshot from an object.\n     *\n     * @private\n     * @param ref The reference to the document.\n     * @param obj The object to store in the DocumentSnapshot.\n     * @return The created DocumentSnapshot.\n     */\n    static fromObject(ref, obj) {\n        const serializer = ref.firestore._serializer;\n        return new DocumentSnapshot(ref, serializer.encodeFields(obj));\n    }\n    /**\n     * Creates a DocumentSnapshot from an UpdateMap.\n     *\n     * This methods expands the top-level field paths in a JavaScript map and\n     * turns { foo.bar : foobar } into { foo { bar : foobar }}\n     *\n     * @private\n     * @param ref The reference to the document.\n     * @param data The field/value map to expand.\n     * @return The created DocumentSnapshot.\n     */\n    static fromUpdateMap(ref, data) {\n        const serializer = ref.firestore._serializer;\n        /**\n         * Merges 'value' at the field path specified by the path array into\n         * 'target'.\n         */\n        function merge(target, value, path, pos) {\n            const key = path[pos];\n            const isLast = pos === path.length - 1;\n            if (target[key] === undefined) {\n                if (isLast) {\n                    if (value instanceof field_value_1.FieldTransform) {\n                        // If there is already data at this path, we need to retain it.\n                        // Otherwise, we don't include it in the DocumentSnapshot.\n                        return !util_1.isEmpty(target) ? target : null;\n                    }\n                    // The merge is done.\n                    const leafNode = serializer.encodeValue(value);\n                    if (leafNode) {\n                        target[key] = leafNode;\n                    }\n                    return target;\n                }\n                else {\n                    // We need to expand the target object.\n                    const childNode = {\n                        mapValue: {\n                            fields: {},\n                        },\n                    };\n                    const nestedValue = merge(childNode.mapValue.fields, value, path, pos + 1);\n                    if (nestedValue) {\n                        childNode.mapValue.fields = nestedValue;\n                        target[key] = childNode;\n                        return target;\n                    }\n                    else {\n                        return !util_1.isEmpty(target) ? target : null;\n                    }\n                }\n            }\n            else {\n                assert(!isLast, \"Can't merge current value into a nested object\");\n                target[key].mapValue.fields = merge(target[key].mapValue.fields, value, path, pos + 1);\n                return target;\n            }\n        }\n        const res = {};\n        for (const [key, value] of data) {\n            const path = key.toArray();\n            merge(res, value, path, 0);\n        }\n        return new DocumentSnapshot(ref, res);\n    }\n    /**\n     * True if the document exists.\n     *\n     * @type {boolean}\n     * @name DocumentSnapshot#exists\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then((documentSnapshot) => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(`Data: ${JSON.stringify(documentSnapshot.data())}`);\n     *   }\n     * });\n     */\n    get exists() {\n        return this._fieldsProto !== undefined;\n    }\n    /**\n     * A [DocumentReference]{@link DocumentReference} for the document\n     * stored in this snapshot.\n     *\n     * @type {DocumentReference}\n     * @name DocumentSnapshot#ref\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then((documentSnapshot) => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(`Found document at '${documentSnapshot.ref.path}'`);\n     *   }\n     * });\n     */\n    get ref() {\n        return this._ref;\n    }\n    /**\n     * The ID of the document for which this DocumentSnapshot contains data.\n     *\n     * @type {string}\n     * @name DocumentSnapshot#id\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then((documentSnapshot) => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(`Document found with name '${documentSnapshot.id}'`);\n     *   }\n     * });\n     */\n    get id() {\n        return this._ref.id;\n    }\n    /**\n     * The time the document was created. Undefined for documents that don't\n     * exist.\n     *\n     * @type {Timestamp|undefined}\n     * @name DocumentSnapshot#createTime\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     let createTime = documentSnapshot.createTime;\n     *     console.log(`Document created at '${createTime.toDate()}'`);\n     *   }\n     * });\n     */\n    get createTime() {\n        return this._createTime;\n    }\n    /**\n     * The time the document was last updated (at the time the snapshot was\n     * generated). Undefined for documents that don't exist.\n     *\n     * @type {Timestamp|undefined}\n     * @name DocumentSnapshot#updateTime\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     let updateTime = documentSnapshot.updateTime;\n     *     console.log(`Document updated at '${updateTime.toDate()}'`);\n     *   }\n     * });\n     */\n    get updateTime() {\n        return this._updateTime;\n    }\n    /**\n     * The time this snapshot was read.\n     *\n     * @type {Timestamp}\n     * @name DocumentSnapshot#readTime\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   let readTime = documentSnapshot.readTime;\n     *   console.log(`Document read at '${readTime.toDate()}'`);\n     * });\n     */\n    get readTime() {\n        if (this._readTime === undefined) {\n            throw new Error(\"Called 'readTime' on a local document\");\n        }\n        return this._readTime;\n    }\n    /**\n     * Retrieves all fields in the document as an object. Returns 'undefined' if\n     * the document doesn't exist.\n     *\n     * @returns {T|undefined} An object containing all fields in the document or\n     * 'undefined' if the document doesn't exist.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   let data = documentSnapshot.data();\n     *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n     * });\n     */\n    data() {\n        const fields = this._fieldsProto;\n        if (fields === undefined) {\n            return undefined;\n        }\n        // We only want to use the converter and create a new QueryDocumentSnapshot\n        // if a converter has been provided.\n        if (this.ref._converter !== types_1.defaultConverter()) {\n            const untypedReference = new reference_1.DocumentReference(this.ref.firestore, this.ref._path);\n            return this.ref._converter.fromFirestore(new QueryDocumentSnapshot(untypedReference, this._fieldsProto, this.readTime, this.createTime, this.updateTime));\n        }\n        else {\n            const obj = {};\n            for (const prop of Object.keys(fields)) {\n                obj[prop] = this._serializer.decodeValue(fields[prop]);\n            }\n            return obj;\n        }\n    }\n    /**\n     * Retrieves the field specified by `field`.\n     *\n     * @param {string|FieldPath} field The field path\n     * (e.g. 'foo' or 'foo.bar') to a specific field.\n     * @returns {*} The data at the specified field location or undefined if no\n     * such field exists.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({ a: { b: 'c' }}).then(() => {\n     *   return documentRef.get();\n     * }).then(documentSnapshot => {\n     *   let field = documentSnapshot.get('a.b');\n     *   console.log(`Retrieved field value: ${field}`);\n     * });\n     */\n    // We deliberately use `any` in the external API to not impose type-checking\n    // on end users.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    get(field) {\n        path_1.validateFieldPath('field', field);\n        const protoField = this.protoField(field);\n        if (protoField === undefined) {\n            return undefined;\n        }\n        return this._serializer.decodeValue(protoField);\n    }\n    /**\n     * Retrieves the field specified by 'fieldPath' in its Protobuf JS\n     * representation.\n     *\n     * @private\n     * @param field The path (e.g. 'foo' or 'foo.bar') to a specific field.\n     * @returns The Protobuf-encoded data at the specified field location or\n     * undefined if no such field exists.\n     */\n    protoField(field) {\n        let fields = this._fieldsProto;\n        if (fields === undefined) {\n            return undefined;\n        }\n        const components = path_1.FieldPath.fromArgument(field).toArray();\n        while (components.length > 1) {\n            fields = fields[components.shift()];\n            if (!fields || !fields.mapValue) {\n                return undefined;\n            }\n            fields = fields.mapValue.fields;\n        }\n        return fields[components[0]];\n    }\n    /**\n     * Convert a document snapshot to the Firestore 'Write' proto.\n     *\n     * @private\n     */\n    toWriteProto() {\n        return {\n            update: {\n                name: this._ref.formattedName,\n                fields: this._fieldsProto,\n            },\n        };\n    }\n    /**\n     * Convert a document snapshot to the Firestore 'Document' proto.\n     *\n     * @private\n     */\n    toDocumentProto() {\n        return {\n            name: this._ref.formattedName,\n            createTime: this.createTime,\n            updateTime: this.updateTime,\n            fields: this._fieldsProto,\n        };\n    }\n    /**\n     * Returns true if the document's data and path in this `DocumentSnapshot` is\n     * equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `DocumentSnapshot` is equal to the provided\n     * value.\n     */\n    isEqual(other) {\n        // Since the read time is different on every document read, we explicitly\n        // ignore all document metadata in this comparison.\n        return (this === other ||\n            (other instanceof DocumentSnapshot &&\n                this._ref.isEqual(other._ref) &&\n                deepEqual(this._fieldsProto, other._fieldsProto)));\n    }\n}\nexports.DocumentSnapshot = DocumentSnapshot;\n/**\n * A QueryDocumentSnapshot contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with [data()]{@link QueryDocumentSnapshot#data}\n * or [get()]{@link DocumentSnapshot#get} to get a specific field.\n *\n * A QueryDocumentSnapshot offers the same API surface as a\n * {@link DocumentSnapshot}. Since query results contain only existing\n * documents, the [exists]{@link DocumentSnapshot#exists} property will\n * always be true and [data()]{@link QueryDocumentSnapshot#data} will never\n * return 'undefined'.\n *\n * @class\n * @extends DocumentSnapshot\n */\nclass QueryDocumentSnapshot extends DocumentSnapshot {\n    /**\n     * The time the document was created.\n     *\n     * @type {Timestamp}\n     * @name QueryDocumentSnapshot#createTime\n     * @readonly\n     * @override\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.get().forEach(snapshot => {\n     *   console.log(`Document created at '${snapshot.createTime.toDate()}'`);\n     * });\n     */\n    get createTime() {\n        return super.createTime;\n    }\n    /**\n     * The time the document was last updated (at the time the snapshot was\n     * generated).\n     *\n     * @type {Timestamp}\n     * @name QueryDocumentSnapshot#updateTime\n     * @readonly\n     * @override\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.get().forEach(snapshot => {\n     *   console.log(`Document updated at '${snapshot.updateTime.toDate()}'`);\n     * });\n     */\n    get updateTime() {\n        return super.updateTime;\n    }\n    /**\n     * Retrieves all fields in the document as an object.\n     *\n     * @override\n     *\n     * @returns {T} An object containing all fields in the document.\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.get().forEach(documentSnapshot => {\n     *   let data = documentSnapshot.data();\n     *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n     * });\n     */\n    data() {\n        const data = super.data();\n        if (!data) {\n            throw new Error('The data in a QueryDocumentSnapshot should always exist.');\n        }\n        return data;\n    }\n}\nexports.QueryDocumentSnapshot = QueryDocumentSnapshot;\n/**\n * A Firestore Document Mask contains the field paths affected by an update.\n *\n * @class\n * @private\n */\nclass DocumentMask {\n    /**\n     * @private\n     * @hideconstructor\n     *\n     * @param fieldPaths The field paths in this mask.\n     */\n    constructor(fieldPaths) {\n        this._sortedPaths = fieldPaths;\n        this._sortedPaths.sort((a, b) => a.compareTo(b));\n    }\n    /**\n     * Creates a document mask with the field paths of a document.\n     *\n     * @private\n     * @param data A map with fields to modify. Only the keys are used to extract\n     * the document mask.\n     */\n    static fromUpdateMap(data) {\n        const fieldPaths = [];\n        data.forEach((value, key) => {\n            if (!(value instanceof field_value_1.FieldTransform) || value.includeInDocumentMask) {\n                fieldPaths.push(path_1.FieldPath.fromArgument(key));\n            }\n        });\n        return new DocumentMask(fieldPaths);\n    }\n    /**\n     * Creates a document mask from an array of field paths.\n     *\n     * @private\n     * @param fieldMask A list of field paths.\n     */\n    static fromFieldMask(fieldMask) {\n        const fieldPaths = [];\n        for (const fieldPath of fieldMask) {\n            fieldPaths.push(path_1.FieldPath.fromArgument(fieldPath));\n        }\n        return new DocumentMask(fieldPaths);\n    }\n    /**\n     * Creates a document mask with the field names of a document.\n     *\n     * @private\n     * @param data An object with fields to modify. Only the keys are used to\n     * extract the document mask.\n     */\n    static fromObject(data) {\n        const fieldPaths = [];\n        function extractFieldPaths(currentData, currentPath) {\n            let isEmpty = true;\n            for (const key of Object.keys(currentData)) {\n                isEmpty = false;\n                // We don't split on dots since fromObject is called with\n                // DocumentData.\n                const childSegment = new path_1.FieldPath(key);\n                const childPath = currentPath\n                    ? currentPath.append(childSegment)\n                    : childSegment;\n                const value = currentData[key];\n                if (value instanceof field_value_1.FieldTransform) {\n                    if (value.includeInDocumentMask) {\n                        fieldPaths.push(childPath);\n                    }\n                }\n                else if (util_1.isPlainObject(value)) {\n                    extractFieldPaths(value, childPath);\n                }\n                else {\n                    fieldPaths.push(childPath);\n                }\n            }\n            // Add a field path for an explicitly updated empty map.\n            if (currentPath && isEmpty) {\n                fieldPaths.push(currentPath);\n            }\n        }\n        extractFieldPaths(data);\n        return new DocumentMask(fieldPaths);\n    }\n    /**\n     * Returns true if this document mask contains no fields.\n     *\n     * @private\n     * @return {boolean} Whether this document mask is empty.\n     */\n    get isEmpty() {\n        return this._sortedPaths.length === 0;\n    }\n    /**\n     * Removes the specified values from a sorted field path array.\n     *\n     * @private\n     * @param input A sorted array of FieldPaths.\n     * @param values An array of FieldPaths to remove.\n     */\n    static removeFromSortedArray(input, values) {\n        for (let i = 0; i < input.length;) {\n            let removed = false;\n            for (const fieldPath of values) {\n                if (input[i].isEqual(fieldPath)) {\n                    input.splice(i, 1);\n                    removed = true;\n                    break;\n                }\n            }\n            if (!removed) {\n                ++i;\n            }\n        }\n    }\n    /**\n     * Removes the field path specified in 'fieldPaths' from this document mask.\n     *\n     * @private\n     * @param fieldPaths An array of FieldPaths.\n     */\n    removeFields(fieldPaths) {\n        DocumentMask.removeFromSortedArray(this._sortedPaths, fieldPaths);\n    }\n    /**\n     * Returns whether this document mask contains 'fieldPath'.\n     *\n     * @private\n     * @param fieldPath The field path to test.\n     * @return Whether this document mask contains 'fieldPath'.\n     */\n    contains(fieldPath) {\n        for (const sortedPath of this._sortedPaths) {\n            const cmp = sortedPath.compareTo(fieldPath);\n            if (cmp === 0) {\n                return true;\n            }\n            else if (cmp > 0) {\n                return false;\n            }\n        }\n        return false;\n    }\n    /**\n     * Removes all properties from 'data' that are not contained in this document\n     * mask.\n     *\n     * @private\n     * @param data An object to filter.\n     * @return A shallow copy of the object filtered by this document mask.\n     */\n    applyTo(data) {\n        /*!\n         * Applies this DocumentMask to 'data' and computes the list of field paths\n         * that were specified in the mask but are not present in 'data'.\n         */\n        const applyDocumentMask = data => {\n            const remainingPaths = this._sortedPaths.slice(0);\n            const processObject = (currentData, currentPath) => {\n                let result = null;\n                Object.keys(currentData).forEach(key => {\n                    const childPath = currentPath\n                        ? currentPath.append(key)\n                        : new path_1.FieldPath(key);\n                    if (this.contains(childPath)) {\n                        DocumentMask.removeFromSortedArray(remainingPaths, [childPath]);\n                        result = result || {};\n                        result[key] = currentData[key];\n                    }\n                    else if (util_1.isObject(currentData[key])) {\n                        const childObject = processObject(currentData[key], childPath);\n                        if (childObject) {\n                            result = result || {};\n                            result[key] = childObject;\n                        }\n                    }\n                });\n                return result;\n            };\n            // processObject() returns 'null' if the DocumentMask is empty.\n            const filteredData = processObject(data) || {};\n            return {\n                filteredData,\n                remainingPaths,\n            };\n        };\n        const result = applyDocumentMask(data);\n        if (result.remainingPaths.length !== 0) {\n            throw new Error(`Input data is missing for field \"${result.remainingPaths[0]}\".`);\n        }\n        return result.filteredData;\n    }\n    /**\n     * Converts a document mask to the Firestore 'DocumentMask' Proto.\n     *\n     * @private\n     * @returns A Firestore 'DocumentMask' Proto.\n     */\n    toProto() {\n        if (this.isEmpty) {\n            return {};\n        }\n        const encodedPaths = [];\n        for (const fieldPath of this._sortedPaths) {\n            encodedPaths.push(fieldPath.formattedName);\n        }\n        return {\n            fieldPaths: encodedPaths,\n        };\n    }\n}\nexports.DocumentMask = DocumentMask;\n/**\n * A Firestore Document Transform.\n *\n * A DocumentTransform contains pending server-side transforms and their\n * corresponding field paths.\n *\n * @private\n * @class\n */\nclass DocumentTransform {\n    /**\n     * @private\n     * @hideconstructor\n     *\n     * @param ref The DocumentReference for this transform.\n     * @param transforms A Map of FieldPaths to FieldTransforms.\n     */\n    constructor(ref, transforms) {\n        this.ref = ref;\n        this.transforms = transforms;\n    }\n    /**\n     * Generates a DocumentTransform from a JavaScript object.\n     *\n     * @private\n     * @param ref The `DocumentReference` to use for the DocumentTransform.\n     * @param obj The object to extract the transformations from.\n     * @returns The Document Transform.\n     */\n    static fromObject(ref, obj) {\n        const updateMap = new Map();\n        for (const prop of Object.keys(obj)) {\n            updateMap.set(new path_1.FieldPath(prop), obj[prop]);\n        }\n        return DocumentTransform.fromUpdateMap(ref, updateMap);\n    }\n    /**\n     * Generates a DocumentTransform from an Update Map.\n     *\n     * @private\n     * @param ref The `DocumentReference` to use for the DocumentTransform.\n     * @param data The update data to extract the transformations from.\n     * @returns The Document Transform.\n     */\n    static fromUpdateMap(ref, data) {\n        const transforms = new Map();\n        function encode_(val, path, allowTransforms) {\n            if (val instanceof field_value_1.FieldTransform && val.includeInDocumentTransform) {\n                if (allowTransforms) {\n                    transforms.set(path, val);\n                }\n                else {\n                    throw new Error(`${val.methodName}() is not supported inside of array values.`);\n                }\n            }\n            else if (Array.isArray(val)) {\n                for (let i = 0; i < val.length; ++i) {\n                    // We need to verify that no array value contains a document transform\n                    encode_(val[i], path.append(String(i)), false);\n                }\n            }\n            else if (util_1.isPlainObject(val)) {\n                for (const prop of Object.keys(val)) {\n                    encode_(val[prop], path.append(new path_1.FieldPath(prop)), allowTransforms);\n                }\n            }\n        }\n        data.forEach((value, key) => {\n            encode_(value, path_1.FieldPath.fromArgument(key), true);\n        });\n        return new DocumentTransform(ref, transforms);\n    }\n    /**\n     * Whether this DocumentTransform contains any actionable transformations.\n     *\n     * @private\n     */\n    get isEmpty() {\n        return this.transforms.size === 0;\n    }\n    /**\n     * Returns the array of fields in this DocumentTransform.\n     *\n     * @private\n     */\n    get fields() {\n        return Array.from(this.transforms.keys());\n    }\n    /**\n     * Validates the user provided field values in this document transform.\n     * @private\n     */\n    validate() {\n        const allowUndefined = !!this.ref.firestore._settings\n            .ignoreUndefinedProperties;\n        this.transforms.forEach(transform => transform.validate(allowUndefined));\n    }\n    /**\n     * Converts a document transform to the Firestore 'FieldTransform' Proto.\n     *\n     * @private\n     * @param serializer The Firestore serializer\n     * @returns A list of Firestore 'FieldTransform' Protos\n     */\n    toProto(serializer) {\n        return Array.from(this.transforms, ([path, transform]) => transform.toProto(serializer, path));\n    }\n}\nexports.DocumentTransform = DocumentTransform;\n/**\n * A Firestore Precondition encapsulates options for database writes.\n *\n * @private\n * @class\n */\nclass Precondition {\n    /**\n     * @private\n     * @hideconstructor\n     *\n     * @param options.exists - Whether the referenced document should exist in\n     * Firestore,\n     * @param options.lastUpdateTime - The last update time of the referenced\n     * document in Firestore.\n     * @param options\n     */\n    constructor(options) {\n        if (options !== undefined) {\n            this._exists = options.exists;\n            this._lastUpdateTime = options.lastUpdateTime;\n        }\n    }\n    /**\n     * Generates the Protobuf `Preconditon` object for this precondition.\n     *\n     * @private\n     * @returns The `Preconditon` Protobuf object or 'null' if there are no\n     * preconditions.\n     */\n    toProto() {\n        if (this.isEmpty) {\n            return null;\n        }\n        const proto = {};\n        if (this._lastUpdateTime !== undefined) {\n            proto.updateTime = this._lastUpdateTime.toProto().timestampValue;\n        }\n        else {\n            proto.exists = this._exists;\n        }\n        return proto;\n    }\n    /**\n     * Whether this DocumentTransform contains any enforcement.\n     *\n     * @private\n     */\n    get isEmpty() {\n        return this._exists === undefined && !this._lastUpdateTime;\n    }\n}\nexports.Precondition = Precondition;\n//# sourceMappingURL=document.js.map"]},"metadata":{},"sourceType":"script"}